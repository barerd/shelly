#!/usr/bin/env perl

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"App/shelly.pm"} = <<'APP_SHELLY';
  package App::shelly;
  
  use strict;
  use warnings;
  
  use Getopt::Long qw(:config gnu_getopt pass_through require_order);
  
  use App::shelly::config qw(config lisp_impl dumped_core_path local_path);
  use App::shelly::command;
  
  sub new {
      my ($class) = @_;
  
      return bless {
          load_path      => [],
          load_libraries => [],
          argv           => [],
      }, $class;
  }
  
  sub parse_options {
      my ( $self, @argv ) = @_;
  
      local @ARGV = @{ $self->{argv} };
      push @ARGV, @argv;
  
      GetOptions(
          'I=s@'      => \$self->{load_path},
          'load|L=s@' => \$self->{load_libraries},
          'file|f=s'  => \$self->{shlyfile},
          'verbose'   => \$self->{verbose},
          'debug'     => \$self->{debug},
      );
  
      $self->{argv} = \@ARGV;
  
      if (@ARGV == 1 && $ARGV[0] =~ /^(?:--version|-V)$/) {
          $self->{version} = 1;
      }
  
      if (!@ARGV || (@ARGV == 1 && $ARGV[0] =~ /^(?:--help|-h)$/)) {
          $self->{help} = 1;
          $self->{argv} = ['shelly::help'];
      }
  }
  
  sub task {
      return $_[0]->{argv}->[0];
  }
  
  sub doit {
      my ($self) = @_;
  
      if ($self->{version}) {
          printf "Shelly ver %s\n", config->{version};
          exit;
      }
  
      unless (exists $ENV{CIM_HOME}) {
          print STDERR "Error: CIM_HOME is not set.\nIf you've never installed CIM, install it from https://github.com/KeenS/CIM first.\n";
          exit 1;
      }
  
      my $command = $self->build_command;
  
      if ( $self->{debug} ) {
          print $command->stringify, "\n";
      }
  
      local $ENV{SHELLY_VERSION} = config->{version};
  
      exec($command->arrayfy);
  }
  
  sub build_command {
      my ($self) = @_;
  
      my $task = $self->task;
  
      return
          $task eq 'install'   ? $self->_build_command_for_install
        : $task eq 'dump-core' ? $self->_build_command_for_dump_core
        : $self->_build_command_for_others;
  }
  
  sub _build_command_for_dump_core {
      my ($self) = @_;
  
      my $command = App::shelly::command->new(verbose => $self->{verbose});
  
      $command->load_shelly;
      $command->check_shelly_version;
      $command->load_libraries($self->{load_libraries});
      $command->run_shelly_command($self->{argv});
  
      return $command;
  }
  
  sub _build_command_for_install {
      my ($self) = @_;
  
      my $command = App::shelly::command->new(verbose => $self->{verbose});
  
      $command->load_shelly;
      $command->load_libraries($self->{load_libraries});
      $command->run_shelly_command($self->{argv});
  
      return $command;
  }
  
  sub _build_command_for_others {
      my ($self) = @_;
  
      my $command = App::shelly::command->new(verbose => $self->{verbose});
  
      if (!exists $ENV{SHELLY_PATH} && -e dumped_core_path) {
          $command->add_option('--core', dumped_core_path);
          $command->add_eval_option(q{(shelly.util:shadowing-use-package :shelly)});
      }
      else {
          if (!exists $ENV{SHELLY_PATH} && lisp_impl =~ /^(?:sbcl|clisp|ccl|alisp)/) {
              print STDERR
                  "Warning: Core image wasn't found for @{[ lisp_impl ]}. It is probably slow, isn't it? Try \"shly dump-core\".\n";
          }
  
          $command->load_shelly;
      }
  
      $command->check_shelly_version;
      $command->add_load_path($self->{load_path});
      $command->load_libraries($self->{load_libraries});
  
      $command->add_eval_option(q{(shelly.util::load-global-shlyfile)});
      $command->add_eval_option(
          defined $self->{shlyfile}
              ? (sprintf q{(shelly.util::load-local-shlyfile #P"%s")}, $self->{shlyfile})
              : q{(shelly.util::load-local-shlyfile)}
      );
  
      $command->run_shelly_command($self->{argv});
  
      return $command;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  App::shelly
  
  =head1 SYNOPSIS
  
  $ shly [options] [atom...]
  
  =head1 OPTIONS
  
  =over 4
  
  =item B<-h, --help>
  
  Show this help.
  
  =item B<-I [directory]>
  
  Specify asdf:*central-registry* directory (several -I's allowed).
  
  =item B<-L, --load [library]>
  
  Specify a library to be loaded before executing the expression (several -L's allowed).
  
  =item B<-V, --version>
  
  Print the version of Shelly and exit.
  
  =item B<--verbose>
  
  Print some informations.
  
  =item B<--debug>
  
  This flag is for Shelly developers.
  
  =back
  
  =cut
APP_SHELLY

$fatpacked{"App/shelly/command.pm"} = <<'APP_SHELLY_COMMAND';
  package App::shelly::command;
  
  use strict;
  use warnings;
  use Path::Class qw(dir);
  
  use App::shelly::config qw(config shelly_path);
  
  sub new {
      my ($class, %args) = @_;
  
      return bless {
          verbose  => $args{verbose},
          options  => [],
      }, $class;
  }
  
  sub add_option {
      my $self = shift;
      push @{ $self->{options} }, @_;
  }
  
  sub add_eval_option {
      my ($self, $command) = @_;
      $self->add_option('-e', $command);
  }
  
  sub load_shelly {
      my ($self) = @_;
  
      if (my $shelly_path = shelly_path) {
          $shelly_path = dir($shelly_path)->absolute;
          $shelly_path =~ s!/?$!/!;
          $self->add_eval_option("(require (quote asdf))");
          $self->add_eval_option(qq'(push #P"$shelly_path" asdf:*central-registry*)');
      }
  
      # NOTE: Mysteriously, this doesn't work on Clozure CL, so loading Shelly as an eval option.
      #$self->add_option('-L', 'shelly');
      $self->add_eval_option(<<END_OF_LISP);
  (let ((*standard-output* (make-broadcast-stream)) #+allegro(*readtable* (copy-readtable)))
    (handler-case #+quicklisp (ql:quickload :shelly) #-quicklisp (asdf:load-system :shelly)
      (#+quicklisp ql::system-not-found #-quicklisp asdf:missing-component (c)
       (format *error-output* "~&Error: ~A~&" c)
       #+quicklisp
       (format *error-output* "~&Try (ql:update-all-dists) to ensure your dist is up to date.~%")
       #+allegro (excl:exit 1 :quiet t)
       #+sbcl    (sb-ext:exit)
       #-(or allegro sbcl) (quit)))
    (values))
  END_OF_LISP
      $self->add_eval_option('(shelly.util::shadowing-use-package :shelly)');
  }
  
  sub check_shelly_version {
      my ($self) = @_;
      if (config->{version}) {
          $self->add_eval_option(qq((shelly.util::check-version "@{[ config->{version} ]}")));
      }
  }
  
  sub add_load_path {
      my ($self, $directories) = @_;
  
      if (@$directories) {
          $self->add_eval_option(
              sprintf(
                  "(shelly.util::add-load-path (list %s))",
                  (join ' ', (map { qq{#P"$_"} } @$directories))
              )
          );
      }
  }
  
  sub load_libraries {
      my ($self, $libraries) = @_;
  
      if (@$libraries) {
          $self->add_option('-L', $_) for @$libraries;
      }
  }
  
  sub run_shelly_command {
      my ($self, $args) = @_;
  
      my @args = @$args;
      my $eval_expr =
          sprintf '(shelly.core::interpret (list %s) :verbose %s)',
              ( join " ", ( map { s/"/\\"/g;"\"$_\"" } @args ) ),
                  $self->{verbose} ? 't' : 'nil';
      $self->add_eval_option($eval_expr);
  }
  
  sub arrayfy {
      my ($self) = @_;
  
      return ('cl', @{ $self->{options} });
  }
  
  sub stringify {
      my ($self) = @_;
  
      return join ' ', $self->arrayfy;
  }
  
  1;
APP_SHELLY_COMMAND

$fatpacked{"App/shelly/config.pm"} = <<'APP_SHELLY_CONFIG';
  package App::shelly::config;
  
  use strict;
  use warnings;
  use Exporter::Lite;
  use Path::Class qw(dir);
  
  our @EXPORT_OK = qw(config config_path lisp_impl dumped_core_path shelly_path local_path);
  
  my $local_base_path = $ENV{HOME} . '/.shelly/';
  
  sub local_path {
      return $local_base_path . $_[0];
  }
  
  sub config_path {
      return local_path('config');
  }
  
  sub shelly_path {
      if (exists $ENV{SHELLY_PATH}) {
          return $ENV{SHELLY_PATH};
      }
      if (-e local_path('shelly/')) {
          return local_path('shelly/')
      }
  }
  
  my $_lisp_impl_cache = undef;
  sub lisp_impl {
      $_lisp_impl_cache ||= do {
          my $lisp_impl = `[ -s "$ENV{CIM_HOME}/config/current.$ENV{CIM_ID}" ] && . "$ENV{CIM_HOME}/config/current.$ENV{CIM_ID}" && echo "\$LISP_IMPL"`;
          chomp $lisp_impl;
  
          $lisp_impl;
      };
  }
  
  sub dumped_core_path {
      my $core_path = 'dumped-cores/' . ( $_[0] || ( lisp_impl . '.core' ) );
      return -e $core_path ? $core_path : local_path($core_path);
  }
  
  sub config {
      my $config_file = &config_path;
  
      my $config =
        -e $config_file
        ? do $config_file
        : {};
  
      return $config;
  }
  
  1;
APP_SHELLY_CONFIG

$fatpacked{"Exporter.pm"} = <<'EXPORTER';
  package Exporter;
  
  require 5.006;
  
  # Be lean.
  #use strict;
  #no strict 'refs';
  
  our $Debug = 0;
  our $ExportLevel = 0;
  our $Verbose ||= 0;
  our $VERSION = '5.68';
  our (%Cache);
  
  sub as_heavy {
    require Exporter::Heavy;
    # Unfortunately, this does not work if the caller is aliased as *name = \&foo
    # Thus the need to create a lot of identical subroutines
    my $c = (caller(1))[3];
    $c =~ s/.*:://;
    \&{"Exporter::Heavy::heavy_$c"};
  }
  
  sub export {
    goto &{as_heavy()};
  }
  
  sub import {
    my $pkg = shift;
    my $callpkg = caller($ExportLevel);
  
    if ($pkg eq "Exporter" and @_ and $_[0] eq "import") {
      *{$callpkg."::import"} = \&import;
      return;
    }
  
    # We *need* to treat @{"$pkg\::EXPORT_FAIL"} since Carp uses it :-(
    my $exports = \@{"$pkg\::EXPORT"};
    # But, avoid creating things if they don't exist, which saves a couple of
    # hundred bytes per package processed.
    my $fail = ${$pkg . '::'}{EXPORT_FAIL} && \@{"$pkg\::EXPORT_FAIL"};
    return export $pkg, $callpkg, @_
      if $Verbose or $Debug or $fail && @$fail > 1;
    my $export_cache = ($Cache{$pkg} ||= {});
    my $args = @_ or @_ = @$exports;
  
    if ($args and not %$export_cache) {
      s/^&//, $export_cache->{$_} = 1
        foreach (@$exports, @{"$pkg\::EXPORT_OK"});
    }
    my $heavy;
    # Try very hard not to use {} and hence have to  enter scope on the foreach
    # We bomb out of the loop with last as soon as heavy is set.
    if ($args or $fail) {
      ($heavy = (/\W/ or $args and not exists $export_cache->{$_}
                 or $fail and @$fail and $_ eq $fail->[0])) and last
                   foreach (@_);
    } else {
      ($heavy = /\W/) and last
        foreach (@_);
    }
    return export $pkg, $callpkg, ($args ? @_ : ()) if $heavy;
    local $SIG{__WARN__} = 
  	sub {require Carp; &Carp::carp} if not $SIG{__WARN__};
    # shortcut for the common case of no type character
    *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  }
  
  # Default methods
  
  sub export_fail {
      my $self = shift;
      @_;
  }
  
  # Unfortunately, caller(1)[3] "does not work" if the caller is aliased as
  # *name = \&foo.  Thus the need to create a lot of identical subroutines
  # Otherwise we could have aliased them to export().
  
  sub export_to_level {
    goto &{as_heavy()};
  }
  
  sub export_tags {
    goto &{as_heavy()};
  }
  
  sub export_ok_tags {
    goto &{as_heavy()};
  }
  
  sub require_version {
    goto &{as_heavy()};
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Exporter - Implements default import method for modules
  
  =head1 SYNOPSIS
  
  In module F<YourModule.pm>:
  
    package YourModule;
    require Exporter;
    @ISA = qw(Exporter);
    @EXPORT_OK = qw(munge frobnicate);  # symbols to export on request
  
  or
  
    package YourModule;
    use Exporter 'import'; # gives you Exporter's import() method directly
    @EXPORT_OK = qw(munge frobnicate);  # symbols to export on request
  
  In other files which wish to use C<YourModule>:
  
    use YourModule qw(frobnicate);      # import listed symbols
    frobnicate ($left, $right)          # calls YourModule::frobnicate
  
  Take a look at L</Good Practices> for some variants
  you will like to use in modern Perl code.
  
  =head1 DESCRIPTION
  
  The Exporter module implements an C<import> method which allows a module
  to export functions and variables to its users' namespaces.  Many modules
  use Exporter rather than implementing their own C<import> method because
  Exporter provides a highly flexible interface, with an implementation optimised
  for the common case.
  
  Perl automatically calls the C<import> method when processing a
  C<use> statement for a module.  Modules and C<use> are documented
  in L<perlfunc> and L<perlmod>.  Understanding the concept of
  modules and how the C<use> statement operates is important to
  understanding the Exporter.
  
  =head2 How to Export
  
  The arrays C<@EXPORT> and C<@EXPORT_OK> in a module hold lists of
  symbols that are going to be exported into the users name space by
  default, or which they can request to be exported, respectively.  The
  symbols can represent functions, scalars, arrays, hashes, or typeglobs.
  The symbols must be given by full name with the exception that the
  ampersand in front of a function is optional, e.g.
  
      @EXPORT    = qw(afunc $scalar @array);   # afunc is a function
      @EXPORT_OK = qw(&bfunc %hash *typeglob); # explicit prefix on &bfunc
  
  If you are only exporting function names it is recommended to omit the
  ampersand, as the implementation is faster this way.
  
  =head2 Selecting What to Export
  
  Do B<not> export method names!
  
  Do B<not> export anything else by default without a good reason!
  
  Exports pollute the namespace of the module user.  If you must export
  try to use C<@EXPORT_OK> in preference to C<@EXPORT> and avoid short or
  common symbol names to reduce the risk of name clashes.
  
  Generally anything not exported is still accessible from outside the
  module using the C<YourModule::item_name> (or C<< $blessed_ref->method >>)
  syntax.  By convention you can use a leading underscore on names to
  informally indicate that they are 'internal' and not for public use.
  
  (It is actually possible to get private functions by saying:
  
    my $subref = sub { ... };
    $subref->(@args);            # Call it as a function
    $obj->$subref(@args);        # Use it as a method
  
  However if you use them for methods it is up to you to figure out
  how to make inheritance work.)
  
  As a general rule, if the module is trying to be object oriented
  then export nothing.  If it's just a collection of functions then
  C<@EXPORT_OK> anything but use C<@EXPORT> with caution.  For function and
  method names use barewords in preference to names prefixed with
  ampersands for the export lists.
  
  Other module design guidelines can be found in L<perlmod>.
  
  =head2 How to Import
  
  In other files which wish to use your module there are three basic ways for
  them to load your module and import its symbols:
  
  =over 4
  
  =item C<use YourModule;>
  
  This imports all the symbols from YourModule's C<@EXPORT> into the namespace
  of the C<use> statement.
  
  =item C<use YourModule ();>
  
  This causes perl to load your module but does not import any symbols.
  
  =item C<use YourModule qw(...);>
  
  This imports only the symbols listed by the caller into their namespace.
  All listed symbols must be in your C<@EXPORT> or C<@EXPORT_OK>, else an error
  occurs.  The advanced export features of Exporter are accessed like this,
  but with list entries that are syntactically distinct from symbol names.
  
  =back
  
  Unless you want to use its advanced features, this is probably all you
  need to know to use Exporter.
  
  =head1 Advanced Features
  
  =head2 Specialised Import Lists
  
  If any of the entries in an import list begins with !, : or / then
  the list is treated as a series of specifications which either add to
  or delete from the list of names to import.  They are processed left to
  right. Specifications are in the form:
  
      [!]name         This name only
      [!]:DEFAULT     All names in @EXPORT
      [!]:tag         All names in $EXPORT_TAGS{tag} anonymous list
      [!]/pattern/    All names in @EXPORT and @EXPORT_OK which match
  
  A leading ! indicates that matching names should be deleted from the
  list of names to import.  If the first specification is a deletion it
  is treated as though preceded by :DEFAULT.  If you just want to import
  extra names in addition to the default set you will still need to
  include :DEFAULT explicitly.
  
  e.g., F<Module.pm> defines:
  
      @EXPORT      = qw(A1 A2 A3 A4 A5);
      @EXPORT_OK   = qw(B1 B2 B3 B4 B5);
      %EXPORT_TAGS = (T1 => [qw(A1 A2 B1 B2)], T2 => [qw(A1 A2 B3 B4)]);
  
  Note that you cannot use tags in @EXPORT or @EXPORT_OK.
  
  Names in EXPORT_TAGS must also appear in @EXPORT or @EXPORT_OK.
  
  An application using Module can say something like:
  
      use Module qw(:DEFAULT :T2 !B3 A3);
  
  Other examples include:
  
      use Socket qw(!/^[AP]F_/ !SOMAXCONN !SOL_SOCKET);
      use POSIX  qw(:errno_h :termios_h !TCSADRAIN !/^EXIT/);
  
  Remember that most patterns (using //) will need to be anchored
  with a leading ^, e.g., C</^EXIT/> rather than C</EXIT/>.
  
  You can say C<BEGIN { $Exporter::Verbose=1 }> to see how the
  specifications are being processed and what is actually being imported
  into modules.
  
  =head2 Exporting Without Using Exporter's import Method
  
  Exporter has a special method, 'export_to_level' which is used in situations
  where you can't directly call Exporter's
  import method.  The export_to_level
  method looks like:
  
      MyPackage->export_to_level(
  	$where_to_export, $package, @what_to_export
      );
  
  where C<$where_to_export> is an integer telling how far up the calling stack
  to export your symbols, and C<@what_to_export> is an array telling what
  symbols *to* export (usually this is C<@_>).  The C<$package> argument is
  currently unused.
  
  For example, suppose that you have a module, A, which already has an
  import function:
  
      package A;
  
      @ISA = qw(Exporter);
      @EXPORT_OK = qw ($b);
  
      sub import
      {
  	$A::b = 1;     # not a very useful import method
      }
  
  and you want to Export symbol C<$A::b> back to the module that called 
  package A.  Since Exporter relies on the import method to work, via 
  inheritance, as it stands Exporter::import() will never get called. 
  Instead, say the following:
  
      package A;
      @ISA = qw(Exporter);
      @EXPORT_OK = qw ($b);
  
      sub import
      {
  	$A::b = 1;
  	A->export_to_level(1, @_);
      }
  
  This will export the symbols one level 'above' the current package - ie: to 
  the program or module that used package A. 
  
  Note: Be careful not to modify C<@_> at all before you call export_to_level
  - or people using your package will get very unexplained results!
  
  =head2 Exporting Without Inheriting from Exporter
  
  By including Exporter in your C<@ISA> you inherit an Exporter's import() method
  but you also inherit several other helper methods which you probably don't
  want.  To avoid this you can do
  
    package YourModule;
    use Exporter qw( import );
  
  which will export Exporter's own import() method into YourModule.
  Everything will work as before but you won't need to include Exporter in
  C<@YourModule::ISA>.
  
  Note: This feature was introduced in version 5.57
  of Exporter, released with perl 5.8.3.
  
  =head2 Module Version Checking
  
  The Exporter module will convert an attempt to import a number from a
  module into a call to C<< $module_name->VERSION($value) >>.  This can
  be used to validate that the version of the module being used is
  greater than or equal to the required version.
  
  For historical reasons, Exporter supplies a C<require_version> method that
  simply delegates to C<VERSION>.  Originally, before C<UNIVERSAL::VERSION>
  existed, Exporter would call C<require_version>.
  
  Since the C<UNIVERSAL::VERSION> method treats the C<$VERSION> number as
  a simple numeric value it will regard version 1.10 as lower than
  1.9.  For this reason it is strongly recommended that you use numbers
  with at least two decimal places, e.g., 1.09.
  
  =head2 Managing Unknown Symbols
  
  In some situations you may want to prevent certain symbols from being
  exported.  Typically this applies to extensions which have functions
  or constants that may not exist on some systems.
  
  The names of any symbols that cannot be exported should be listed
  in the C<@EXPORT_FAIL> array.
  
  If a module attempts to import any of these symbols the Exporter
  will give the module an opportunity to handle the situation before
  generating an error.  The Exporter will call an export_fail method
  with a list of the failed symbols:
  
    @failed_symbols = $module_name->export_fail(@failed_symbols);
  
  If the C<export_fail> method returns an empty list then no error is
  recorded and all the requested symbols are exported.  If the returned
  list is not empty then an error is generated for each symbol and the
  export fails.  The Exporter provides a default C<export_fail> method which
  simply returns the list unchanged.
  
  Uses for the C<export_fail> method include giving better error messages
  for some symbols and performing lazy architectural checks (put more
  symbols into C<@EXPORT_FAIL> by default and then take them out if someone
  actually tries to use them and an expensive check shows that they are
  usable on that platform).
  
  =head2 Tag Handling Utility Functions
  
  Since the symbols listed within C<%EXPORT_TAGS> must also appear in either
  C<@EXPORT> or C<@EXPORT_OK>, two utility functions are provided which allow
  you to easily add tagged sets of symbols to C<@EXPORT> or C<@EXPORT_OK>:
  
    %EXPORT_TAGS = (foo => [qw(aa bb cc)], bar => [qw(aa cc dd)]);
  
    Exporter::export_tags('foo');     # add aa, bb and cc to @EXPORT
    Exporter::export_ok_tags('bar');  # add aa, cc and dd to @EXPORT_OK
  
  Any names which are not tags are added to C<@EXPORT> or C<@EXPORT_OK>
  unchanged but will trigger a warning (with C<-w>) to avoid misspelt tags
  names being silently added to C<@EXPORT> or C<@EXPORT_OK>.  Future versions
  may make this a fatal error.
  
  =head2 Generating Combined Tags
  
  If several symbol categories exist in C<%EXPORT_TAGS>, it's usually
  useful to create the utility ":all" to simplify "use" statements.
  
  The simplest way to do this is:
  
    %EXPORT_TAGS = (foo => [qw(aa bb cc)], bar => [qw(aa cc dd)]);
  
    # add all the other ":class" tags to the ":all" class,
    # deleting duplicates
    {
      my %seen;
  
      push @{$EXPORT_TAGS{all}},
        grep {!$seen{$_}++} @{$EXPORT_TAGS{$_}} foreach keys %EXPORT_TAGS;
    }
  
  F<CGI.pm> creates an ":all" tag which contains some (but not really
  all) of its categories.  That could be done with one small
  change:
  
    # add some of the other ":class" tags to the ":all" class,
    # deleting duplicates
    {
      my %seen;
  
      push @{$EXPORT_TAGS{all}},
        grep {!$seen{$_}++} @{$EXPORT_TAGS{$_}}
          foreach qw/html2 html3 netscape form cgi internal/;
    }
  
  Note that the tag names in C<%EXPORT_TAGS> don't have the leading ':'.
  
  =head2 C<AUTOLOAD>ed Constants
  
  Many modules make use of C<AUTOLOAD>ing for constant subroutines to
  avoid having to compile and waste memory on rarely used values (see
  L<perlsub> for details on constant subroutines).  Calls to such
  constant subroutines are not optimized away at compile time because
  they can't be checked at compile time for constancy.
  
  Even if a prototype is available at compile time, the body of the
  subroutine is not (it hasn't been C<AUTOLOAD>ed yet).  perl needs to
  examine both the C<()> prototype and the body of a subroutine at
  compile time to detect that it can safely replace calls to that
  subroutine with the constant value.
  
  A workaround for this is to call the constants once in a C<BEGIN> block:
  
     package My ;
  
     use Socket ;
  
     foo( SO_LINGER );  ## SO_LINGER NOT optimized away; called at runtime
     BEGIN { SO_LINGER }
     foo( SO_LINGER );  ## SO_LINGER optimized away at compile time.
  
  This forces the C<AUTOLOAD> for C<SO_LINGER> to take place before
  SO_LINGER is encountered later in C<My> package.
  
  If you are writing a package that C<AUTOLOAD>s, consider forcing
  an C<AUTOLOAD> for any constants explicitly imported by other packages
  or which are usually used when your package is C<use>d.
  
  =head1 Good Practices
  
  =head2 Declaring C<@EXPORT_OK> and Friends
  
  When using C<Exporter> with the standard C<strict> and C<warnings>
  pragmas, the C<our> keyword is needed to declare the package
  variables C<@EXPORT_OK>, C<@EXPORT>, C<@ISA>, etc.
  
    our @ISA = qw(Exporter);
    our @EXPORT_OK = qw(munge frobnicate);
  
  If backward compatibility for Perls under 5.6 is important,
  one must write instead a C<use vars> statement.
  
    use vars qw(@ISA @EXPORT_OK);
    @ISA = qw(Exporter);
    @EXPORT_OK = qw(munge frobnicate);
  
  =head2 Playing Safe
  
  There are some caveats with the use of runtime statements
  like C<require Exporter> and the assignment to package
  variables, which can very subtle for the unaware programmer.
  This may happen for instance with mutually recursive
  modules, which are affected by the time the relevant
  constructions are executed.
  
  The ideal (but a bit ugly) way to never have to think
  about that is to use C<BEGIN> blocks.  So the first part
  of the L</SYNOPSIS> code could be rewritten as:
  
    package YourModule;
  
    use strict;
    use warnings;
  
    our (@ISA, @EXPORT_OK);
    BEGIN {
       require Exporter;
       @ISA = qw(Exporter);
       @EXPORT_OK = qw(munge frobnicate);  # symbols to export on request
    }
  
  The C<BEGIN> will assure that the loading of F<Exporter.pm>
  and the assignments to C<@ISA> and C<@EXPORT_OK> happen
  immediately, leaving no room for something to get awry
  or just plain wrong.
  
  With respect to loading C<Exporter> and inheriting, there
  are alternatives with the use of modules like C<base> and C<parent>.
  
    use base qw( Exporter );
    # or
    use parent qw( Exporter );
  
  Any of these statements are nice replacements for
  C<BEGIN { require Exporter; @ISA = qw(Exporter); }>
  with the same compile-time effect.  The basic difference
  is that C<base> code interacts with declared C<fields>
  while C<parent> is a streamlined version of the older
  C<base> code to just establish the IS-A relationship.
  
  For more details, see the documentation and code of
  L<base> and L<parent>.
  
  Another thorough remedy to that runtime
  vs. compile-time trap is to use L<Exporter::Easy>,
  which is a wrapper of Exporter that allows all
  boilerplate code at a single gulp in the
  use statement.
  
     use Exporter::Easy (
         OK => [ qw(munge frobnicate) ],
     );
     # @ISA setup is automatic
     # all assignments happen at compile time
  
  =head2 What Not to Export
  
  You have been warned already in L</Selecting What to Export>
  to not export:
  
  =over 4
  
  =item *
  
  method names (because you don't need to
  and that's likely to not do what you want),
  
  =item *
  
  anything by default (because you don't want to surprise your users...
  badly)
  
  =item *
  
  anything you don't need to (because less is more)
  
  =back
  
  There's one more item to add to this list.  Do B<not>
  export variable names.  Just because C<Exporter> lets you
  do that, it does not mean you should.
  
    @EXPORT_OK = qw( $svar @avar %hvar ); # DON'T!
  
  Exporting variables is not a good idea.  They can
  change under the hood, provoking horrible
  effects at-a-distance, that are too hard to track
  and to fix.  Trust me: they are not worth it.
  
  To provide the capability to set/get class-wide
  settings, it is best instead to provide accessors
  as subroutines or class methods instead.
  
  =head1 SEE ALSO
  
  C<Exporter> is definitely not the only module with
  symbol exporter capabilities.  At CPAN, you may find
  a bunch of them.  Some are lighter.  Some
  provide improved APIs and features.  Peek the one
  that fits your needs.  The following is
  a sample list of such modules.
  
      Exporter::Easy
      Exporter::Lite
      Exporter::Renaming
      Exporter::Tidy
      Sub::Exporter / Sub::Installer
      Perl6::Export / Perl6::Export::Attrs
  
  =head1 LICENSE
  
  This library is free software.  You can redistribute it
  and/or modify it under the same terms as Perl itself.
  
  =cut
  
  
  
EXPORTER

$fatpacked{"Exporter/Heavy.pm"} = <<'EXPORTER_HEAVY';
  package Exporter::Heavy;
  
  use strict;
  no strict 'refs';
  
  # On one line so MakeMaker will see it.
  require Exporter;  our $VERSION = $Exporter::VERSION;
  
  =head1 NAME
  
  Exporter::Heavy - Exporter guts
  
  =head1 SYNOPSIS
  
  (internal use only)
  
  =head1 DESCRIPTION
  
  No user-serviceable parts inside.
  
  =cut
  
  #
  # We go to a lot of trouble not to 'require Carp' at file scope,
  #  because Carp requires Exporter, and something has to give.
  #
  
  sub _rebuild_cache {
      my ($pkg, $exports, $cache) = @_;
      s/^&// foreach @$exports;
      @{$cache}{@$exports} = (1) x @$exports;
      my $ok = \@{"${pkg}::EXPORT_OK"};
      if (@$ok) {
  	s/^&// foreach @$ok;
  	@{$cache}{@$ok} = (1) x @$ok;
      }
  }
  
  sub heavy_export {
  
      # First make import warnings look like they're coming from the "use".
      local $SIG{__WARN__} = sub {
  	my $text = shift;
  	if ($text =~ s/ at \S*Exporter\S*.pm line \d+.*\n//) {
  	    require Carp;
  	    local $Carp::CarpLevel = 1;	# ignore package calling us too.
  	    Carp::carp($text);
  	}
  	else {
  	    warn $text;
  	}
      };
      local $SIG{__DIE__} = sub {
  	require Carp;
  	local $Carp::CarpLevel = 1;	# ignore package calling us too.
  	Carp::croak("$_[0]Illegal null symbol in \@${1}::EXPORT")
  	    if $_[0] =~ /^Unable to create sub named "(.*?)::"/;
      };
  
      my($pkg, $callpkg, @imports) = @_;
      my($type, $sym, $cache_is_current, $oops);
      my($exports, $export_cache) = (\@{"${pkg}::EXPORT"},
                                     $Exporter::Cache{$pkg} ||= {});
  
      if (@imports) {
  	if (!%$export_cache) {
  	    _rebuild_cache ($pkg, $exports, $export_cache);
  	    $cache_is_current = 1;
  	}
  
  	if (grep m{^[/!:]}, @imports) {
  	    my $tagsref = \%{"${pkg}::EXPORT_TAGS"};
  	    my $tagdata;
  	    my %imports;
  	    my($remove, $spec, @names, @allexports);
  	    # negated first item implies starting with default set:
  	    unshift @imports, ':DEFAULT' if $imports[0] =~ m/^!/;
  	    foreach $spec (@imports){
  		$remove = $spec =~ s/^!//;
  
  		if ($spec =~ s/^://){
  		    if ($spec eq 'DEFAULT'){
  			@names = @$exports;
  		    }
  		    elsif ($tagdata = $tagsref->{$spec}) {
  			@names = @$tagdata;
  		    }
  		    else {
  			warn qq["$spec" is not defined in %${pkg}::EXPORT_TAGS];
  			++$oops;
  			next;
  		    }
  		}
  		elsif ($spec =~ m:^/(.*)/$:){
  		    my $patn = $1;
  		    @allexports = keys %$export_cache unless @allexports; # only do keys once
  		    @names = grep(/$patn/, @allexports); # not anchored by default
  		}
  		else {
  		    @names = ($spec); # is a normal symbol name
  		}
  
  		warn "Import ".($remove ? "del":"add").": @names "
  		    if $Exporter::Verbose;
  
  		if ($remove) {
  		   foreach $sym (@names) { delete $imports{$sym} } 
  		}
  		else {
  		    @imports{@names} = (1) x @names;
  		}
  	    }
  	    @imports = keys %imports;
  	}
  
          my @carp;
  	foreach $sym (@imports) {
  	    if (!$export_cache->{$sym}) {
  		if ($sym =~ m/^\d/) {
  		    $pkg->VERSION($sym); # inherit from UNIVERSAL
  		    # If the version number was the only thing specified
  		    # then we should act as if nothing was specified:
  		    if (@imports == 1) {
  			@imports = @$exports;
  			last;
  		    }
  		    # We need a way to emulate 'use Foo ()' but still
  		    # allow an easy version check: "use Foo 1.23, ''";
  		    if (@imports == 2 and !$imports[1]) {
  			@imports = ();
  			last;
  		    }
  		} elsif ($sym !~ s/^&// || !$export_cache->{$sym}) {
  		    # Last chance - see if they've updated EXPORT_OK since we
  		    # cached it.
  
  		    unless ($cache_is_current) {
  			%$export_cache = ();
  			_rebuild_cache ($pkg, $exports, $export_cache);
  			$cache_is_current = 1;
  		    }
  
  		    if (!$export_cache->{$sym}) {
  			# accumulate the non-exports
  			push @carp,
  			  qq["$sym" is not exported by the $pkg module\n];
  			$oops++;
  		    }
  		}
  	    }
  	}
  	if ($oops) {
  	    require Carp;
  	    Carp::croak("@{carp}Can't continue after import errors");
  	}
      }
      else {
  	@imports = @$exports;
      }
  
      my($fail, $fail_cache) = (\@{"${pkg}::EXPORT_FAIL"},
                                $Exporter::FailCache{$pkg} ||= {});
  
      if (@$fail) {
  	if (!%$fail_cache) {
  	    # Build cache of symbols. Optimise the lookup by adding
  	    # barewords twice... both with and without a leading &.
  	    # (Technique could be applied to $export_cache at cost of memory)
  	    my @expanded = map { /^\w/ ? ($_, '&'.$_) : $_ } @$fail;
  	    warn "${pkg}::EXPORT_FAIL cached: @expanded" if $Exporter::Verbose;
  	    @{$fail_cache}{@expanded} = (1) x @expanded;
  	}
  	my @failed;
  	foreach $sym (@imports) { push(@failed, $sym) if $fail_cache->{$sym} }
  	if (@failed) {
  	    @failed = $pkg->export_fail(@failed);
  	    foreach $sym (@failed) {
                  require Carp;
  		Carp::carp(qq["$sym" is not implemented by the $pkg module ],
  			"on this architecture");
  	    }
  	    if (@failed) {
  		require Carp;
  		Carp::croak("Can't continue after import errors");
  	    }
  	}
      }
  
      warn "Importing into $callpkg from $pkg: ",
  		join(", ",sort @imports) if $Exporter::Verbose;
  
      foreach $sym (@imports) {
  	# shortcut for the common case of no type character
  	(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
  	    unless $sym =~ s/^(\W)//;
  	$type = $1;
  	no warnings 'once';
  	*{"${callpkg}::$sym"} =
  	    $type eq '&' ? \&{"${pkg}::$sym"} :
  	    $type eq '$' ? \${"${pkg}::$sym"} :
  	    $type eq '@' ? \@{"${pkg}::$sym"} :
  	    $type eq '%' ? \%{"${pkg}::$sym"} :
  	    $type eq '*' ?  *{"${pkg}::$sym"} :
  	    do { require Carp; Carp::croak("Can't export symbol: $type$sym") };
      }
  }
  
  sub heavy_export_to_level
  {
        my $pkg = shift;
        my $level = shift;
        (undef) = shift;			# XXX redundant arg
        my $callpkg = caller($level);
        $pkg->export($callpkg, @_);
  }
  
  # Utility functions
  
  sub _push_tags {
      my($pkg, $var, $syms) = @_;
      my @nontag = ();
      my $export_tags = \%{"${pkg}::EXPORT_TAGS"};
      push(@{"${pkg}::$var"},
  	map { $export_tags->{$_} ? @{$export_tags->{$_}} 
                                   : scalar(push(@nontag,$_),$_) }
  		(@$syms) ? @$syms : keys %$export_tags);
      if (@nontag and $^W) {
  	# This may change to a die one day
  	require Carp;
  	Carp::carp(join(", ", @nontag)." are not tags of $pkg");
      }
  }
  
  sub heavy_require_version {
      my($self, $wanted) = @_;
      my $pkg = ref $self || $self;
      return ${pkg}->VERSION($wanted);
  }
  
  sub heavy_export_tags {
    _push_tags((caller)[0], "EXPORT",    \@_);
  }
  
  sub heavy_export_ok_tags {
    _push_tags((caller)[0], "EXPORT_OK", \@_);
  }
  
  1;
EXPORTER_HEAVY

$fatpacked{"Exporter/Lite.pm"} = <<'EXPORTER_LITE';
  package Exporter::Lite;
  
  require 5.004;
  
  # Using strict or vars almost doubles our load time.  Turn them back
  # on when debugging.
  #use strict 'vars';  # we're going to be doing a lot of sym refs
  #use vars qw($VERSION @EXPORT);
  
  $VERSION = 0.02;
  @EXPORT = qw(import);   # we'll know pretty fast if it doesn't work :)
  
  
  
  sub import {
      my($exporter, @imports)  = @_;
      my($caller, $file, $line) = caller;
  
      unless( @imports ) {        # Default import.
          @imports = @{$exporter.'::EXPORT'};
      }
      else {
          # Because @EXPORT_OK = () would indicate that nothing is
          # to be exported, we cannot simply check the length of @EXPORT_OK.
          # We must to oddness to see if the variable exists at all as
          # well as avoid autovivification.
          # XXX idea stolen from base.pm, this might be all unnecessary
          my $eokglob;
          if( $eokglob = ${$exporter.'::'}{EXPORT_OK} and *$eokglob{ARRAY} ) {
              if( @{$exporter.'::EXPORT_OK'} ) {
                  # This can also be cached.
                  my %ok = map { s/^&//; $_ => 1 } @{$exporter.'::EXPORT_OK'},
                                                   @{$exporter.'::EXPORT'};
  
                  my($denied) = grep {s/^&//; !$ok{$_}} @imports;
                  _not_exported($denied, $exporter, $file, $line) if $denied;
              }
              else {      # We don't export anything.
                  _not_exported($imports[0], $exporter, $file, $line);
              }
          }
      }
  
      _export($caller, $exporter, @imports);
  }
  
  
  
  sub _export {
      my($caller, $exporter, @imports) = @_;
  
      # Stole this from Exporter::Heavy.  I'm sure it can be written better
      # but I'm lazy at the moment.
      foreach my $sym (@imports) {
          # shortcut for the common case of no type character
          (*{$caller.'::'.$sym} = \&{$exporter.'::'.$sym}, next)
              unless $sym =~ s/^(\W)//;
  
          my $type = $1;
          my $caller_sym = $caller.'::'.$sym;
          my $export_sym = $exporter.'::'.$sym;
          *{$caller_sym} =
              $type eq '&' ? \&{$export_sym} :
              $type eq '$' ? \${$export_sym} :
              $type eq '@' ? \@{$export_sym} :
              $type eq '%' ? \%{$export_sym} :
              $type eq '*' ?  *{$export_sym} :
              do { require Carp; Carp::croak("Can't export symbol: $type$sym") };
      }
  }
  
  
  #"#
  sub _not_exported {
      my($thing, $exporter, $file, $line) = @_;
      die sprintf qq|"%s" is not exported by the %s module at %s line %d\n|,
          $thing, $exporter, $file, $line;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Exporter::Lite - Lightweight exporting of variables
  
  =head1 SYNOPSIS
  
    package Foo;
    use Exporter::Lite;
  
    # Just like Exporter.
    @EXPORT       = qw($This That);
    @EXPORT_OK    = qw(@Left %Right);
  
  
    # Meanwhile, in another piece of code!
    package Bar;
    use Foo;  # exports $This and &That.
  
  
  =head1 DESCRIPTION
  
  This is an alternative to Exporter intended to provide a lightweight
  subset of its functionality.  It supports C<import()>, C<@EXPORT> and
  C<@EXPORT_OK> and not a whole lot else.
  
  Unlike Exporter, it is not necessary to inherit from Exporter::Lite
  (ie. no C<@ISA = qw(Exporter::Lite)> mantra).  Exporter::Lite simply
  exports its import() function.  This might be called a "mix-in".
  
  Setting up a module to export its variables and functions is simple:
  
      package My::Module;
      use Exporter::Lite;
  
      @EXPORT = qw($Foo bar);
  
  now when you C<use My::Module>, C<$Foo> and C<bar()> will show up.
  
  In order to make exporting optional, use @EXPORT_OK.
  
      package My::Module;
      use Exporter::Lite;
  
      @EXPORT_OK = qw($Foo bar);
  
  when My::Module is used, C<$Foo> and C<bar()> will I<not> show up.
  You have to ask for them.  C<use My::Module qw($Foo bar)>.
  
  =head1 Methods
  
  Export::Lite has one public method, import(), which is called
  automaticly when your modules is use()'d.  
  
  In normal usage you don't have to worry about this at all.
  
  =over 4
  
  =item B<import>
  
    Some::Module->import;
    Some::Module->import(@symbols);
  
  Works just like C<Exporter::import()> excepting it only honors
  @Some::Module::EXPORT and @Some::Module::EXPORT_OK.
  
  The given @symbols are exported to the current package provided they
  are in @Some::Module::EXPORT or @Some::Module::EXPORT_OK.  Otherwise
  an exception is thrown (ie. the program dies).
  
  If @symbols is not given, everything in @Some::Module::EXPORT is
  exported.
  
  =back
  
  =head1 DIAGNOSTICS
  
  =over 4
  
  =item '"%s" is not exported by the %s module'
  
  Attempted to import a symbol which is not in @EXPORT or @EXPORT_OK.
  
  =item 'Can\'t export symbol: %s'
  
  Attempted to import a symbol of an unknown type (ie. the leading $@% salad
  wasn't recognized).
  
  =back
  
  =head1 BUGS and CAVEATS
  
  Its not yet clear if this is actually any lighter or faster than
  Exporter.  I know its at least on par.
  
  OTOH, the docs are much clearer and not having to say C<@ISA =
  qw(Exporter)> is kinda nice.
  
  =head1 AUTHORS
  
  Michael G Schwern <schwern@pobox.com>
  
  =head1 LICENSE
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  See F<http://www.perl.com/perl/misc/Artistic.html>
  
  =head1 SEE ALSO
  
  L<Exporter>, L<Exporter::Simple>, L<UNIVERSAL::exports>
  
  =cut
EXPORTER_LITE

$fatpacked{"Path/Class.pm"} = <<'PATH_CLASS';
  use strict;
  
  package Path::Class;
  {
    $Path::Class::VERSION = '0.32';
  }
  
  {
    ## no critic
    no strict 'vars';
    @ISA = qw(Exporter);
    @EXPORT    = qw(file dir);
    @EXPORT_OK = qw(file dir foreign_file foreign_dir tempdir);
  }
  
  use Exporter;
  use Path::Class::File;
  use Path::Class::Dir;
  use File::Temp ();
  
  sub file { Path::Class::File->new(@_) }
  sub dir  { Path::Class::Dir ->new(@_) }
  sub foreign_file { Path::Class::File->new_foreign(@_) }
  sub foreign_dir  { Path::Class::Dir ->new_foreign(@_) }
  sub tempdir { Path::Class::Dir->new(File::Temp::tempdir(@_)) }
  
  
  1;
  __END__
  
  =head1 NAME
  
  Path::Class - Cross-platform path specification manipulation
  
  =head1 VERSION
  
  version 0.32
  
  =head1 SYNOPSIS
  
    use Path::Class;
    
    my $dir  = dir('foo', 'bar');       # Path::Class::Dir object
    my $file = file('bob', 'file.txt'); # Path::Class::File object
    
    # Stringifies to 'foo/bar' on Unix, 'foo\bar' on Windows, etc.
    print "dir: $dir\n";
    
    # Stringifies to 'bob/file.txt' on Unix, 'bob\file.txt' on Windows
    print "file: $file\n";
    
    my $subdir  = $dir->subdir('baz');  # foo/bar/baz
    my $parent  = $subdir->parent;      # foo/bar
    my $parent2 = $parent->parent;      # foo
    
    my $dir2 = $file->dir;              # bob
  
    # Work with foreign paths
    use Path::Class qw(foreign_file foreign_dir);
    my $file = foreign_file('Mac', ':foo:file.txt');
    print $file->dir;                   # :foo:
    print $file->as_foreign('Win32');   # foo\file.txt
    
    # Interact with the underlying filesystem:
    
    # $dir_handle is an IO::Dir object
    my $dir_handle = $dir->open or die "Can't read $dir: $!";
    
    # $file_handle is an IO::File object
    my $file_handle = $file->open($mode) or die "Can't read $file: $!";
  
  =head1 DESCRIPTION
  
  C<Path::Class> is a module for manipulation of file and directory
  specifications (strings describing their locations, like
  C<'/home/ken/foo.txt'> or C<'C:\Windows\Foo.txt'>) in a cross-platform
  manner.  It supports pretty much every platform Perl runs on,
  including Unix, Windows, Mac, VMS, Epoc, Cygwin, OS/2, and NetWare.
  
  The well-known module L<File::Spec> also provides this service, but
  it's sort of awkward to use well, so people sometimes avoid it, or use
  it in a way that won't actually work properly on platforms
  significantly different than the ones they've tested their code on.
  
  In fact, C<Path::Class> uses C<File::Spec> internally, wrapping all
  the unsightly details so you can concentrate on your application code.
  Whereas C<File::Spec> provides functions for some common path
  manipulations, C<Path::Class> provides an object-oriented model of the
  world of path specifications and their underlying semantics.
  C<File::Spec> doesn't create any objects, and its classes represent
  the different ways in which paths must be manipulated on various
  platforms (not a very intuitive concept).  C<Path::Class> creates
  objects representing files and directories, and provides methods that
  relate them to each other.  For instance, the following C<File::Spec>
  code:
  
   my $absolute = File::Spec->file_name_is_absolute(
                    File::Spec->catfile( @dirs, $file )
                  );
  
  can be written using C<Path::Class> as
  
   my $absolute = Path::Class::File->new( @dirs, $file )->is_absolute;
  
  or even as 
  
   my $absolute = file( @dirs, $file )->is_absolute;
  
  Similar readability improvements should happen all over the place when
  using C<Path::Class>.
  
  Using C<Path::Class> can help solve real problems in your code too -
  for instance, how many people actually take the "volume" (like C<C:>
  on Windows) into account when writing C<File::Spec>-using code?  I
  thought not.  But if you use C<Path::Class>, your file and directory objects
  will know what volumes they refer to and do the right thing.
  
  The guts of the C<Path::Class> code live in the L<Path::Class::File>
  and L<Path::Class::Dir> modules, so please see those
  modules' documentation for more details about how to use them.
  
  =head2 EXPORT
  
  The following functions are exported by default.
  
  =over 4
  
  =item file
  
  A synonym for C<< Path::Class::File->new >>.
  
  =item dir
  
  A synonym for C<< Path::Class::Dir->new >>.
  
  =back
  
  If you would like to prevent their export, you may explicitly pass an
  empty list to perl's C<use>, i.e. C<use Path::Class ()>.
  
  The following are exported only on demand.
  
  =over 4
  
  =item foreign_file
  
  A synonym for C<< Path::Class::File->new_foreign >>.
  
  =item foreign_dir
  
  A synonym for C<< Path::Class::Dir->new_foreign >>.
  
  =item tempdir
  
  Create a new Path::Class::Dir instance pointed to temporary directory.
  
    my $temp = Path::Class::tempdir(CLEANUP => 1);
  
  A synonym for C<< Path::Class::Dir->new(File::Temp::tempdir(@_)) >>.
  
  =back
  
  =head1 Notes on Cross-Platform Compatibility
  
  Although it is much easier to write cross-platform-friendly code with
  this module than with C<File::Spec>, there are still some issues to be
  aware of.
  
  =over 4
  
  =item *
  
  On some platforms, notably VMS and some older versions of DOS (I think),
  all filenames must have an extension.  Thus if you create a file
  called F<foo/bar> and then ask for a list of files in the directory
  F<foo>, you may find a file called F<bar.> instead of the F<bar> you
  were expecting.  Thus it might be a good idea to use an extension in
  the first place.
  
  =back
  
  =head1 AUTHOR
  
  Ken Williams, KWILLIAMS@cpan.org
  
  =head1 COPYRIGHT
  
  Copyright (c) Ken Williams.  All rights reserved.
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  
  =head1 SEE ALSO
  
  L<Path::Class::Dir>, L<Path::Class::File>, L<File::Spec>
  
  =cut
PATH_CLASS

$fatpacked{"Path/Class/Dir.pm"} = <<'PATH_CLASS_DIR';
  use strict;
  
  package Path::Class::Dir;
  {
    $Path::Class::Dir::VERSION = '0.32';
  }
  
  use Path::Class::File;
  use Carp();
  use base qw(Path::Class::Entity);
  
  use IO::Dir ();
  use File::Path ();
  use File::Temp ();
  use Scalar::Util ();
  
  # updir & curdir on the local machine, for screening them out in
  # children().  Note that they don't respect 'foreign' semantics.
  my $Updir  = __PACKAGE__->_spec->updir;
  my $Curdir = __PACKAGE__->_spec->curdir;
  
  sub new {
    my $self = shift->SUPER::new();
  
    # If the only arg is undef, it's probably a mistake.  Without this
    # special case here, we'd return the root directory, which is a
    # lousy thing to do to someone when they made a mistake.  Return
    # undef instead.
    return if @_==1 && !defined($_[0]);
  
    my $s = $self->_spec;
    
    my $first = (@_ == 0     ? $s->curdir :
  	       $_[0] eq '' ? (shift, $s->rootdir) :
  	       shift()
  	      );
    
    $self->{dirs} = [];
    if ( Scalar::Util::blessed($first) && $first->isa("Path::Class::Dir") ) {
      $self->{volume} = $first->{volume};
      push @{$self->{dirs}}, @{$first->{dirs}};
    }
    else {
      ($self->{volume}, my $dirs) = $s->splitpath( $s->canonpath("$first") , 1);
      push @{$self->{dirs}}, $dirs eq $s->rootdir ? "" : $s->splitdir($dirs);
    }
  
    push @{$self->{dirs}}, map {
      Scalar::Util::blessed($_) && $_->isa("Path::Class::Dir")
        ? @{$_->{dirs}}
        : $s->splitdir($_)
    } @_;
  
  
    return $self;
  }
  
  sub file_class { "Path::Class::File" }
  
  sub is_dir { 1 }
  
  sub as_foreign {
    my ($self, $type) = @_;
  
    my $foreign = do {
      local $self->{file_spec_class} = $self->_spec_class($type);
      $self->SUPER::new;
    };
    
    # Clone internal structure
    $foreign->{volume} = $self->{volume};
    my ($u, $fu) = ($self->_spec->updir, $foreign->_spec->updir);
    $foreign->{dirs} = [ map {$_ eq $u ? $fu : $_} @{$self->{dirs}}];
    return $foreign;
  }
  
  sub stringify {
    my $self = shift;
    my $s = $self->_spec;
    return $s->catpath($self->{volume},
  		     $s->catdir(@{$self->{dirs}}),
  		     '');
  }
  
  sub volume { shift()->{volume} }
  
  sub file {
    local $Path::Class::Foreign = $_[0]->{file_spec_class} if $_[0]->{file_spec_class};
    return $_[0]->file_class->new(@_);
  }
  
  sub basename { shift()->{dirs}[-1] }
  
  sub dir_list {
    my $self = shift;
    my $d = $self->{dirs};
    return @$d unless @_;
    
    my $offset = shift;
    if ($offset < 0) { $offset = $#$d + $offset + 1 }
    
    return wantarray ? @$d[$offset .. $#$d] : $d->[$offset] unless @_;
    
    my $length = shift;
    if ($length < 0) { $length = $#$d + $length + 1 - $offset }
    return @$d[$offset .. $length + $offset - 1];
  }
  
  sub components {
    my $self = shift;
    return $self->dir_list(@_);
  }
  
  sub subdir {
    my $self = shift;
    return $self->new($self, @_);
  }
  
  sub parent {
    my $self = shift;
    my $dirs = $self->{dirs};
    my ($curdir, $updir) = ($self->_spec->curdir, $self->_spec->updir);
  
    if ($self->is_absolute) {
      my $parent = $self->new($self);
      pop @{$parent->{dirs}} if @$dirs > 1;
      return $parent;
  
    } elsif ($self eq $curdir) {
      return $self->new($updir);
  
    } elsif (!grep {$_ ne $updir} @$dirs) {  # All updirs
      return $self->new($self, $updir); # Add one more
  
    } elsif (@$dirs == 1) {
      return $self->new($curdir);
  
    } else {
      my $parent = $self->new($self);
      pop @{$parent->{dirs}};
      return $parent;
    }
  }
  
  sub relative {
    # File::Spec->abs2rel before version 3.13 returned the empty string
    # when the two paths were equal - work around it here.
    my $self = shift;
    my $rel = $self->_spec->abs2rel($self->stringify, @_);
    return $self->new( length $rel ? $rel : $self->_spec->curdir );
  }
  
  sub open  { IO::Dir->new(@_) }
  sub mkpath { File::Path::mkpath(shift()->stringify, @_) }
  sub rmtree { File::Path::rmtree(shift()->stringify, @_) }
  
  sub remove {
    rmdir( shift() );
  }
  
  sub traverse {
    my $self = shift;
    my ($callback, @args) = @_;
    my @children = $self->children;
    return $self->$callback(
      sub {
        my @inner_args = @_;
        return map { $_->traverse($callback, @inner_args) } @children;
      },
      @args
    );
  }
  
  sub traverse_if {
    my $self = shift;
    my ($callback, $condition, @args) = @_;
    my @children = grep { $condition->($_) } $self->children;
    return $self->$callback(
      sub {
        my @inner_args = @_;
        return map { $_->traverse_if($callback, $condition, @inner_args) } @children;
      },
      @args
    );
  }
  
  sub recurse {
    my $self = shift;
    my %opts = (preorder => 1, depthfirst => 0, @_);
    
    my $callback = $opts{callback}
      or Carp::croak( "Must provide a 'callback' parameter to recurse()" );
    
    my @queue = ($self);
    
    my $visit_entry;
    my $visit_dir = 
      $opts{depthfirst} && $opts{preorder}
      ? sub {
        my $dir = shift;
        my $ret = $callback->($dir);
        unless( ($ret||'') eq $self->PRUNE ) {
            unshift @queue, $dir->children;
        }
      }
      : $opts{preorder}
      ? sub {
        my $dir = shift;
        my $ret = $callback->($dir);
        unless( ($ret||'') eq $self->PRUNE ) {
            push @queue, $dir->children;
        }
      }
      : sub {
        my $dir = shift;
        $visit_entry->($_) foreach $dir->children;
        $callback->($dir);
      };
    
    $visit_entry = sub {
      my $entry = shift;
      if ($entry->is_dir) { $visit_dir->($entry) } # Will call $callback
      else { $callback->($entry) }
    };
    
    while (@queue) {
      $visit_entry->( shift @queue );
    }
  }
  
  sub children {
    my ($self, %opts) = @_;
    
    my $dh = $self->open or Carp::croak( "Can't open directory $self: $!" );
    
    my @out;
    while (defined(my $entry = $dh->read)) {
      next if !$opts{all} && $self->_is_local_dot_dir($entry);
      next if ($opts{no_hidden} && $entry =~ /^\./);
      push @out, $self->file($entry);
      $out[-1] = $self->subdir($entry) if -d $out[-1];
    }
    return @out;
  }
  
  sub _is_local_dot_dir {
    my $self = shift;
    my $dir  = shift;
  
    return ($dir eq $Updir or $dir eq $Curdir);
  }
  
  sub next {
    my $self = shift;
    unless ($self->{dh}) {
      $self->{dh} = $self->open or Carp::croak( "Can't open directory $self: $!" );
    }
    
    my $next = $self->{dh}->read;
    unless (defined $next) {
      delete $self->{dh};
      ## no critic
      return undef;
    }
    
    # Figure out whether it's a file or directory
    my $file = $self->file($next);
    $file = $self->subdir($next) if -d $file;
    return $file;
  }
  
  sub subsumes {
    my ($self, $other) = @_;
    die "No second entity given to subsumes()" unless $other;
    
    $other = $self->new($other) unless UNIVERSAL::isa($other, __PACKAGE__);
    $other = $other->dir unless $other->is_dir;
    
    if ($self->is_absolute) {
      $other = $other->absolute;
    } elsif ($other->is_absolute) {
      $self = $self->absolute;
    }
  
    $self = $self->cleanup;
    $other = $other->cleanup;
  
    if ($self->volume) {
      return 0 unless $other->volume eq $self->volume;
    }
  
    # The root dir subsumes everything (but ignore the volume because
    # we've already checked that)
    return 1 if "@{$self->{dirs}}" eq "@{$self->new('')->{dirs}}";
    
    my $i = 0;
    while ($i <= $#{ $self->{dirs} }) {
      return 0 if $i > $#{ $other->{dirs} };
      return 0 if $self->{dirs}[$i] ne $other->{dirs}[$i];
      $i++;
    }
    return 1;
  }
  
  sub contains {
    my ($self, $other) = @_;
    return !!(-d $self and (-e $other or -l $other) and $self->subsumes($other));
  }
  
  sub tempfile {
    my $self = shift;
    return File::Temp::tempfile(@_, DIR => $self->stringify);
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Path::Class::Dir - Objects representing directories
  
  =head1 VERSION
  
  version 0.32
  
  =head1 SYNOPSIS
  
    use Path::Class qw(dir);  # Export a short constructor
    
    my $dir = dir('foo', 'bar');       # Path::Class::Dir object
    my $dir = Path::Class::Dir->new('foo', 'bar');  # Same thing
    
    # Stringifies to 'foo/bar' on Unix, 'foo\bar' on Windows, etc.
    print "dir: $dir\n";
    
    if ($dir->is_absolute) { ... }
    if ($dir->is_relative) { ... }
    
    my $v = $dir->volume; # Could be 'C:' on Windows, empty string
                          # on Unix, 'Macintosh HD:' on Mac OS
    
    $dir->cleanup; # Perform logical cleanup of pathname
    $dir->resolve; # Perform physical cleanup of pathname
    
    my $file = $dir->file('file.txt'); # A file in this directory
    my $subdir = $dir->subdir('george'); # A subdirectory
    my $parent = $dir->parent; # The parent directory, 'foo'
    
    my $abs = $dir->absolute; # Transform to absolute path
    my $rel = $abs->relative; # Transform to relative path
    my $rel = $abs->relative('/foo'); # Relative to /foo
    
    print $dir->as_foreign('Mac');   # :foo:bar:
    print $dir->as_foreign('Win32'); #  foo\bar
  
    # Iterate with IO::Dir methods:
    my $handle = $dir->open;
    while (my $file = $handle->read) {
      $file = $dir->file($file);  # Turn into Path::Class::File object
      ...
    }
    
    # Iterate with Path::Class methods:
    while (my $file = $dir->next) {
      # $file is a Path::Class::File or Path::Class::Dir object
      ...
    }
  
  
  =head1 DESCRIPTION
  
  The C<Path::Class::Dir> class contains functionality for manipulating
  directory names in a cross-platform way.
  
  =head1 METHODS
  
  =over 4
  
  =item $dir = Path::Class::Dir->new( <dir1>, <dir2>, ... )
  
  =item $dir = dir( <dir1>, <dir2>, ... )
  
  Creates a new C<Path::Class::Dir> object and returns it.  The
  arguments specify names of directories which will be joined to create
  a single directory object.  A volume may also be specified as the
  first argument, or as part of the first argument.  You can use
  platform-neutral syntax:
  
    my $dir = dir( 'foo', 'bar', 'baz' );
  
  or platform-native syntax:
  
    my $dir = dir( 'foo/bar/baz' );
  
  or a mixture of the two:
  
    my $dir = dir( 'foo/bar', 'baz' );
  
  All three of the above examples create relative paths.  To create an
  absolute path, either use the platform native syntax for doing so:
  
    my $dir = dir( '/var/tmp' );
  
  or use an empty string as the first argument:
  
    my $dir = dir( '', 'var', 'tmp' );
  
  If the second form seems awkward, that's somewhat intentional - paths
  like C</var/tmp> or C<\Windows> aren't cross-platform concepts in the
  first place (many non-Unix platforms don't have a notion of a "root
  directory"), so they probably shouldn't appear in your code if you're
  trying to be cross-platform.  The first form is perfectly natural,
  because paths like this may come from config files, user input, or
  whatever.
  
  As a special case, since it doesn't otherwise mean anything useful and
  it's convenient to define this way, C<< Path::Class::Dir->new() >> (or
  C<dir()>) refers to the current directory (C<< File::Spec->curdir >>).
  To get the current directory as an absolute path, do C<<
  dir()->absolute >>.
  
  Finally, as another special case C<dir(undef)> will return undef,
  since that's usually an accident on the part of the caller, and
  returning the root directory would be a nasty surprise just asking for
  trouble a few lines later.
  
  =item $dir->stringify
  
  This method is called internally when a C<Path::Class::Dir> object is
  used in a string context, so the following are equivalent:
  
    $string = $dir->stringify;
    $string = "$dir";
  
  =item $dir->volume
  
  Returns the volume (e.g. C<C:> on Windows, C<Macintosh HD:> on Mac OS,
  etc.) of the directory object, if any.  Otherwise, returns the empty
  string.
  
  =item $dir->basename
  
  Returns the last directory name of the path as a string.
  
  =item $dir->is_dir
  
  Returns a boolean value indicating whether this object represents a
  directory.  Not surprisingly, L<Path::Class::File> objects always
  return false, and C<Path::Class::Dir> objects always return true.
  
  =item $dir->is_absolute
  
  Returns true or false depending on whether the directory refers to an
  absolute path specifier (like C</usr/local> or C<\Windows>).
  
  =item $dir->is_relative
  
  Returns true or false depending on whether the directory refers to a
  relative path specifier (like C<lib/foo> or C<./dir>).
  
  =item $dir->cleanup
  
  Performs a logical cleanup of the file path.  For instance:
  
    my $dir = dir('/foo//baz/./foo')->cleanup;
    # $dir now represents '/foo/baz/foo';
  
  =item $dir->resolve
  
  Performs a physical cleanup of the file path.  For instance:
  
    my $dir = dir('/foo//baz/../foo')->resolve;
    # $dir now represents '/foo/foo', assuming no symlinks
  
  This actually consults the filesystem to verify the validity of the
  path.
  
  =item $file = $dir->file( <dir1>, <dir2>, ..., <file> )
  
  Returns a L<Path::Class::File> object representing an entry in C<$dir>
  or one of its subdirectories.  Internally, this just calls C<<
  Path::Class::File->new( @_ ) >>.
  
  =item $subdir = $dir->subdir( <dir1>, <dir2>, ... )
  
  Returns a new C<Path::Class::Dir> object representing a subdirectory
  of C<$dir>.
  
  =item $parent = $dir->parent
  
  Returns the parent directory of C<$dir>.  Note that this is the
  I<logical> parent, not necessarily the physical parent.  It really
  means we just chop off entries from the end of the directory list
  until we cain't chop no more.  If the directory is relative, we start
  using the relative forms of parent directories.
  
  The following code demonstrates the behavior on absolute and relative
  directories:
  
    $dir = dir('/foo/bar');
    for (1..6) {
      print "Absolute: $dir\n";
      $dir = $dir->parent;
    }
    
    $dir = dir('foo/bar');
    for (1..6) {
      print "Relative: $dir\n";
      $dir = $dir->parent;
    }
    
    ########### Output on Unix ################
    Absolute: /foo/bar
    Absolute: /foo
    Absolute: /
    Absolute: /
    Absolute: /
    Absolute: /
    Relative: foo/bar
    Relative: foo
    Relative: .
    Relative: ..
    Relative: ../..
    Relative: ../../..
  
  =item @list = $dir->children
  
  Returns a list of L<Path::Class::File> and/or C<Path::Class::Dir>
  objects listed in this directory, or in scalar context the number of
  such objects.  Obviously, it is necessary for C<$dir> to
  exist and be readable in order to find its children.
  
  Note that the children are returned as subdirectories of C<$dir>,
  i.e. the children of F<foo> will be F<foo/bar> and F<foo/baz>, not
  F<bar> and F<baz>.
  
  Ordinarily C<children()> will not include the I<self> and I<parent>
  entries C<.> and C<..> (or their equivalents on non-Unix systems),
  because that's like I'm-my-own-grandpa business.  If you do want all
  directory entries including these special ones, pass a true value for
  the C<all> parameter:
  
    @c = $dir->children(); # Just the children
    @c = $dir->children(all => 1); # All entries
  
  In addition, there's a C<no_hidden> parameter that will exclude all
  normally "hidden" entries - on Unix this means excluding all entries
  that begin with a dot (C<.>):
  
    @c = $dir->children(no_hidden => 1); # Just normally-visible entries
  
  
  =item $abs = $dir->absolute
  
  Returns a C<Path::Class::Dir> object representing C<$dir> as an
  absolute path.  An optional argument, given as either a string or a
  C<Path::Class::Dir> object, specifies the directory to use as the base
  of relativity - otherwise the current working directory will be used.
  
  =item $rel = $dir->relative
  
  Returns a C<Path::Class::Dir> object representing C<$dir> as a
  relative path.  An optional argument, given as either a string or a
  C<Path::Class::Dir> object, specifies the directory to use as the base
  of relativity - otherwise the current working directory will be used.
  
  =item $boolean = $dir->subsumes($other)
  
  Returns true if this directory spec subsumes the other spec, and false
  otherwise.  Think of "subsumes" as "contains", but we only look at the
  I<specs>, not whether C<$dir> actually contains C<$other> on the
  filesystem.
  
  The C<$other> argument may be a C<Path::Class::Dir> object, a
  L<Path::Class::File> object, or a string.  In the latter case, we
  assume it's a directory.
  
    # Examples:
    dir('foo/bar' )->subsumes(dir('foo/bar/baz'))  # True
    dir('/foo/bar')->subsumes(dir('/foo/bar/baz')) # True
    dir('foo/bar' )->subsumes(dir('bar/baz'))      # False
    dir('/foo/bar')->subsumes(dir('foo/bar'))      # False
  
  
  =item $boolean = $dir->contains($other)
  
  Returns true if this directory actually contains C<$other> on the
  filesystem.  C<$other> doesn't have to be a direct child of C<$dir>,
  it just has to be subsumed.
  
  =item $foreign = $dir->as_foreign($type)
  
  Returns a C<Path::Class::Dir> object representing C<$dir> as it would
  be specified on a system of type C<$type>.  Known types include
  C<Unix>, C<Win32>, C<Mac>, C<VMS>, and C<OS2>, i.e. anything for which
  there is a subclass of C<File::Spec>.
  
  Any generated objects (subdirectories, files, parents, etc.) will also
  retain this type.
  
  =item $foreign = Path::Class::Dir->new_foreign($type, @args)
  
  Returns a C<Path::Class::Dir> object representing C<$dir> as it would
  be specified on a system of type C<$type>.  Known types include
  C<Unix>, C<Win32>, C<Mac>, C<VMS>, and C<OS2>, i.e. anything for which
  there is a subclass of C<File::Spec>.
  
  The arguments in C<@args> are the same as they would be specified in
  C<new()>.
  
  =item @list = $dir->dir_list([OFFSET, [LENGTH]])
  
  Returns the list of strings internally representing this directory
  structure.  Each successive member of the list is understood to be an
  entry in its predecessor's directory list.  By contract, C<<
  Path::Class->new( $dir->dir_list ) >> should be equivalent to C<$dir>.
  
  The semantics of this method are similar to Perl's C<splice> or
  C<substr> functions; they return C<LENGTH> elements starting at
  C<OFFSET>.  If C<LENGTH> is omitted, returns all the elements starting
  at C<OFFSET> up to the end of the list.  If C<LENGTH> is negative,
  returns the elements from C<OFFSET> onward except for C<-LENGTH>
  elements at the end.  If C<OFFSET> is negative, it counts backward
  C<OFFSET> elements from the end of the list.  If C<OFFSET> and
  C<LENGTH> are both omitted, the entire list is returned.
  
  In a scalar context, C<dir_list()> with no arguments returns the
  number of entries in the directory list; C<dir_list(OFFSET)> returns
  the single element at that offset; C<dir_list(OFFSET, LENGTH)> returns
  the final element that would have been returned in a list context.
  
  =item $dir->components
  
  Identical to c<dir_list()>.  It exists because there's an analogous
  method C<dir_list()> in the C<Path::Class::File> class that also
  returns the basename string, so this method lets someone call
  C<components()> without caring whether the object is a file or a
  directory.
  
  =item $fh = $dir->open()
  
  Passes C<$dir> to C<< IO::Dir->open >> and returns the result as an
  L<IO::Dir> object.  If the opening fails, C<undef> is returned and
  C<$!> is set.
  
  =item $dir->mkpath($verbose, $mode)
  
  Passes all arguments, including C<$dir>, to C<< File::Path::mkpath()
  >> and returns the result (a list of all directories created).
  
  =item $dir->rmtree($verbose, $cautious)
  
  Passes all arguments, including C<$dir>, to C<< File::Path::rmtree()
  >> and returns the result (the number of files successfully deleted).
  
  =item $dir->remove()
  
  Removes the directory, which must be empty.  Returns a boolean value
  indicating whether or not the directory was successfully removed.
  This method is mainly provided for consistency with
  C<Path::Class::File>'s C<remove()> method.
  
  =item $dir->tempfile(...)
  
  An interface to L<File::Temp>'s C<tempfile()> function.  Just like
  that function, if you call this in a scalar context, the return value
  is the filehandle and the file is C<unlink>ed as soon as possible
  (which is immediately on Unix-like platforms).  If called in a list
  context, the return values are the filehandle and the filename.
  
  The given directory is passed as the C<DIR> parameter.
  
  Here's an example of pretty good usage which doesn't allow race
  conditions, won't leave yucky tempfiles around on your filesystem,
  etc.:
  
    my $fh = $dir->tempfile;
    print $fh "Here's some data...\n";
    seek($fh, 0, 0);
    while (<$fh>) { do something... }
  
  Or in combination with a C<fork>:
  
    my $fh = $dir->tempfile;
    print $fh "Here's some more data...\n";
    seek($fh, 0, 0);
    if ($pid=fork()) {
      wait;
    } else {
      something($_) while <$fh>;
    }
  
  
  =item $dir_or_file = $dir->next()
  
  A convenient way to iterate through directory contents.  The first
  time C<next()> is called, it will C<open()> the directory and read the
  first item from it, returning the result as a C<Path::Class::Dir> or
  L<Path::Class::File> object (depending, of course, on its actual
  type).  Each subsequent call to C<next()> will simply iterate over the
  directory's contents, until there are no more items in the directory,
  and then the undefined value is returned.  For example, to iterate
  over all the regular files in a directory:
  
    while (my $file = $dir->next) {
      next unless -f $file;
      my $fh = $file->open('r') or die "Can't read $file: $!";
      ...
    }
  
  If an error occurs when opening the directory (for instance, it
  doesn't exist or isn't readable), C<next()> will throw an exception
  with the value of C<$!>.
  
  =item $dir->traverse( sub { ... }, @args )
  
  Calls the given callback for the root, passing it a continuation
  function which, when called, will call this recursively on each of its
  children. The callback function should be of the form:
  
    sub {
      my ($child, $cont, @args) = @_;
      # ...
    }
  
  For instance, to calculate the number of files in a directory, you
  can do this:
  
    my $nfiles = $dir->traverse(sub {
      my ($child, $cont) = @_;
      return sum($cont->(), ($child->is_dir ? 0 : 1));
    });
  
  or to calculate the maximum depth of a directory:
  
    my $depth = $dir->traverse(sub {
      my ($child, $cont, $depth) = @_;
      return max($cont->($depth + 1), $depth);
    }, 0);
  
  You can also choose not to call the callback in certain situations:
  
    $dir->traverse(sub {
      my ($child, $cont) = @_;
      return if -l $child; # don't follow symlinks
      # do something with $child
      return $cont->();
    });
  
  =item $dir->traverse_if( sub { ... }, sub { ... }, @args )
  
  traverse with additional "should I visit this child" callback.
  Particularly useful in case examined tree contains inaccessible
  directories.
  
  Canonical example:
  
    $dir->traverse_if(
      sub {
         my ($child, $cont) = @_;
         # do something with $child
         return $cont->();
      }, 
      sub {
         my ($child) = @_;
         # Process only readable items
         return -r $child;
      });
  
  Second callback gets single parameter: child. Only children for
  which it returns true will be processed by the first callback.
  
  Remaining parameters are interpreted as in traverse, in particular
  C<traverse_if(callback, sub { 1 }, @args> is equivalent to
  C<traverse(callback, @args)>.
  
  =item $dir->recurse( callback => sub {...} )
  
  Iterates through this directory and all of its children, and all of
  its children's children, etc., calling the C<callback> subroutine for
  each entry.  This is a lot like what the L<File::Find> module does,
  and of course C<File::Find> will work fine on L<Path::Class> objects,
  but the advantage of the C<recurse()> method is that it will also feed
  your callback routine C<Path::Class> objects rather than just pathname
  strings.
  
  The C<recurse()> method requires a C<callback> parameter specifying
  the subroutine to invoke for each entry.  It will be passed the
  C<Path::Class> object as its first argument.
  
  C<recurse()> also accepts two boolean parameters, C<depthfirst> and
  C<preorder> that control the order of recursion.  The default is a
  preorder, breadth-first search, i.e. C<< depthfirst => 0, preorder => 1 >>.
  At the time of this writing, all combinations of these two parameters
  are supported I<except> C<< depthfirst => 0, preorder => 0 >>.
  
  C<callback> is normally not required to return any value. If it
  returns special constant C<Path::Class::Entity::PRUNE()> (more easily
  available as C<$item->PRUNE>),  no children of analyzed
  item will be analyzed (mostly as if you set C<$File::Find::prune=1>). Of course
  pruning is available only in C<preorder>, in postorder return value
  has no effect.
  
  =item $st = $file->stat()
  
  Invokes C<< File::stat::stat() >> on this directory and returns a
  C<File::stat> object representing the result.
  
  =item $st = $file->lstat()
  
  Same as C<stat()>, but if C<$file> is a symbolic link, C<lstat()>
  stats the link instead of the directory the link points to.
  
  =item $class = $file->file_class()
  
  Returns the class which should be used to create file objects.
  
  Generally overridden whenever this class is subclassed.
  
  =back
  
  =head1 AUTHOR
  
  Ken Williams, kwilliams@cpan.org
  
  =head1 SEE ALSO
  
  L<Path::Class>, L<Path::Class::File>, L<File::Spec>
  
  =cut
PATH_CLASS_DIR

$fatpacked{"Path/Class/Entity.pm"} = <<'PATH_CLASS_ENTITY';
  use strict;
  
  package Path::Class::Entity;
  {
    $Path::Class::Entity::VERSION = '0.32';
  }
  
  use File::Spec 3.26;
  use File::stat ();
  use Cwd;
  use Carp();
  
  use overload
    (
     q[""] => 'stringify',
     'bool' => 'boolify',
     fallback => 1,
    );
  
  sub new {
    my $from = shift;
    my ($class, $fs_class) = (ref($from)
  			    ? (ref $from, $from->{file_spec_class})
  			    : ($from, $Path::Class::Foreign));
    return bless {file_spec_class => $fs_class}, $class;
  }
  
  sub is_dir { 0 }
  
  sub _spec_class {
    my ($class, $type) = @_;
  
    die "Invalid system type '$type'" unless ($type) = $type =~ /^(\w+)$/;  # Untaint
    my $spec = "File::Spec::$type";
    ## no critic
    eval "require $spec; 1" or die $@;
    return $spec;
  }
  
  sub new_foreign {
    my ($class, $type) = (shift, shift);
    local $Path::Class::Foreign = $class->_spec_class($type);
    return $class->new(@_);
  }
  
  sub _spec { (ref($_[0]) && $_[0]->{file_spec_class}) || 'File::Spec' }
  
  sub boolify { 1 }
    
  sub is_absolute { 
    # 5.6.0 has a bug with regexes and stringification that's ticked by
    # file_name_is_absolute().  Help it along with an explicit stringify().
    $_[0]->_spec->file_name_is_absolute($_[0]->stringify) 
  }
  
  sub is_relative { ! $_[0]->is_absolute }
  
  sub cleanup {
    my $self = shift;
    my $cleaned = $self->new( $self->_spec->canonpath("$self") );
    %$self = %$cleaned;
    return $self;
  }
  
  sub resolve {
    my $self = shift;
    Carp::croak($! . " $self") unless -e $self;  # No such file or directory
    my $cleaned = $self->new( scalar Cwd::realpath($self->stringify) );
  
    # realpath() always returns absolute path, kind of annoying
    $cleaned = $cleaned->relative if $self->is_relative;
  
    %$self = %$cleaned;
    return $self;
  }
  
  sub absolute {
    my $self = shift;
    return $self if $self->is_absolute;
    return $self->new($self->_spec->rel2abs($self->stringify, @_));
  }
  
  sub relative {
    my $self = shift;
    return $self->new($self->_spec->abs2rel($self->stringify, @_));
  }
  
  sub stat  { File::stat::stat("$_[0]") }
  sub lstat { File::stat::lstat("$_[0]") }
  
  sub PRUNE { return \&PRUNE; }
  
  1;
  __END__
  
  =head1 NAME
  
  Path::Class::Entity - Base class for files and directories
  
  =head1 VERSION
  
  version 0.32
  
  =head1 DESCRIPTION
  
  This class is the base class for C<Path::Class::File> and
  C<Path::Class::Dir>, it is not used directly by callers.
  
  =head1 AUTHOR
  
  Ken Williams, kwilliams@cpan.org
  
  =head1 SEE ALSO
  
  Path::Class
  
  =cut
PATH_CLASS_ENTITY

$fatpacked{"Path/Class/File.pm"} = <<'PATH_CLASS_FILE';
  use strict;
  
  package Path::Class::File;
  {
    $Path::Class::File::VERSION = '0.32';
  }
  
  use Path::Class::Dir;
  use base qw(Path::Class::Entity);
  use Carp;
  
  use IO::File ();
  
  sub new {
    my $self = shift->SUPER::new;
    my $file = pop();
    my @dirs = @_;
  
    my ($volume, $dirs, $base) = $self->_spec->splitpath($file);
    
    if (length $dirs) {
      push @dirs, $self->_spec->catpath($volume, $dirs, '');
    }
    
    $self->{dir}  = @dirs ? $self->dir_class->new(@dirs) : undef;
    $self->{file} = $base;
    
    return $self;
  }
  
  sub dir_class { "Path::Class::Dir" }
  
  sub as_foreign {
    my ($self, $type) = @_;
    local $Path::Class::Foreign = $self->_spec_class($type);
    my $foreign = ref($self)->SUPER::new;
    $foreign->{dir} = $self->{dir}->as_foreign($type) if defined $self->{dir};
    $foreign->{file} = $self->{file};
    return $foreign;
  }
  
  sub stringify {
    my $self = shift;
    return $self->{file} unless defined $self->{dir};
    return $self->_spec->catfile($self->{dir}->stringify, $self->{file});
  }
  
  sub dir {
    my $self = shift;
    return $self->{dir} if defined $self->{dir};
    return $self->dir_class->new($self->_spec->curdir);
  }
  BEGIN { *parent = \&dir; }
  
  sub volume {
    my $self = shift;
    return '' unless defined $self->{dir};
    return $self->{dir}->volume;
  }
  
  sub components {
    my $self = shift;
    die "Arguments are not currently supported by File->components()" if @_;
    return ($self->dir->components, $self->basename);
  }
  
  sub basename { shift->{file} }
  sub open  { IO::File->new(@_) }
  
  sub openr { $_[0]->open('r') or croak "Can't read $_[0]: $!"  }
  sub openw { $_[0]->open('w') or croak "Can't write to $_[0]: $!" }
  sub opena { $_[0]->open('a') or croak "Can't append to $_[0]: $!" }
  
  sub touch {
    my $self = shift;
    if (-e $self) {
      my $now = time();
      utime $now, $now, $self;
    } else {
      $self->openw;
    }
  }
  
  sub slurp {
    my ($self, %args) = @_;
    my $iomode = $args{iomode} || 'r';
    my $fh = $self->open($iomode) or croak "Can't read $self: $!";
  
    if (wantarray) {
      my @data = <$fh>;
      chomp @data if $args{chomped} or $args{chomp};
  
      if ( my $splitter = $args{split} ) {
        @data = map { [ split $splitter, $_ ] } @data;
      }
  
      return @data;
    }
  
  
    croak "'split' argument can only be used in list context"
      if $args{split};
  
  
    if ($args{chomped} or $args{chomp}) {
      chomp( my @data = <$fh> );
      return join '', @data;
    }
  
  
    local $/;
    return <$fh>;
  }
  
  sub spew {
      my $self = shift;
      my %args = splice( @_, 0, @_-1 );
  
      my $iomode = $args{iomode} || 'w';
      my $fh = $self->open( $iomode ) or croak "Can't write to $self: $!";
  
      if (ref($_[0]) eq 'ARRAY') {
          # Use old-school for loop to avoid copying.
          for (my $i = 0; $i < @{ $_[0] }; $i++) {
              print $fh $_[0]->[$i];
          }
      }
      else {
          print $fh $_[0];
      }
  
      return;
  }
  
  sub remove {
    my $file = shift->stringify;
    return unlink $file unless -e $file; # Sets $! correctly
    1 while unlink $file;
    return not -e $file;
  }
  
  sub traverse {
    my $self = shift;
    my ($callback, @args) = @_;
    return $self->$callback(sub { () }, @args);
  }
  
  sub traverse_if {
    my $self = shift;
    my ($callback, $condition, @args) = @_;
    return $self->$callback(sub { () }, @args);
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Path::Class::File - Objects representing files
  
  =head1 VERSION
  
  version 0.32
  
  =head1 SYNOPSIS
  
    use Path::Class qw(file);  # Export a short constructor
    
    my $file = file('foo', 'bar.txt');  # Path::Class::File object
    my $file = Path::Class::File->new('foo', 'bar.txt'); # Same thing
    
    # Stringifies to 'foo/bar.txt' on Unix, 'foo\bar.txt' on Windows, etc.
    print "file: $file\n";
    
    if ($file->is_absolute) { ... }
    if ($file->is_relative) { ... }
    
    my $v = $file->volume; # Could be 'C:' on Windows, empty string
                           # on Unix, 'Macintosh HD:' on Mac OS
    
    $file->cleanup; # Perform logical cleanup of pathname
    $file->resolve; # Perform physical cleanup of pathname
    
    my $dir = $file->dir;  # A Path::Class::Dir object
    
    my $abs = $file->absolute; # Transform to absolute path
    my $rel = $file->relative; # Transform to relative path
  
  =head1 DESCRIPTION
  
  The C<Path::Class::File> class contains functionality for manipulating
  file names in a cross-platform way.
  
  =head1 METHODS
  
  =over 4
  
  =item $file = Path::Class::File->new( <dir1>, <dir2>, ..., <file> )
  
  =item $file = file( <dir1>, <dir2>, ..., <file> )
  
  Creates a new C<Path::Class::File> object and returns it.  The
  arguments specify the path to the file.  Any volume may also be
  specified as the first argument, or as part of the first argument.
  You can use platform-neutral syntax:
  
    my $file = file( 'foo', 'bar', 'baz.txt' );
  
  or platform-native syntax:
  
    my $file = file( 'foo/bar/baz.txt' );
  
  or a mixture of the two:
  
    my $file = file( 'foo/bar', 'baz.txt' );
  
  All three of the above examples create relative paths.  To create an
  absolute path, either use the platform native syntax for doing so:
  
    my $file = file( '/var/tmp/foo.txt' );
  
  or use an empty string as the first argument:
  
    my $file = file( '', 'var', 'tmp', 'foo.txt' );
  
  If the second form seems awkward, that's somewhat intentional - paths
  like C</var/tmp> or C<\Windows> aren't cross-platform concepts in the
  first place, so they probably shouldn't appear in your code if you're
  trying to be cross-platform.  The first form is perfectly fine,
  because paths like this may come from config files, user input, or
  whatever.
  
  =item $file->stringify
  
  This method is called internally when a C<Path::Class::File> object is
  used in a string context, so the following are equivalent:
  
    $string = $file->stringify;
    $string = "$file";
  
  =item $file->volume
  
  Returns the volume (e.g. C<C:> on Windows, C<Macintosh HD:> on Mac OS,
  etc.) of the object, if any.  Otherwise, returns the empty string.
  
  =item $file->basename
  
  Returns the name of the file as a string, without the directory
  portion (if any).
  
  =item $file->components
  
  Returns a list of the directory components of this file, followed by
  the basename.
  
  Note: unlike C<< $dir->components >>, this method currently does not
  accept any arguments to select which elements of the list will be
  returned.  It may do so in the future.  Currently it throws an
  exception if such arguments are present.
  
  
  =item $file->is_dir
  
  Returns a boolean value indicating whether this object represents a
  directory.  Not surprisingly, C<Path::Class::File> objects always
  return false, and L<Path::Class::Dir> objects always return true.
  
  =item $file->is_absolute
  
  Returns true or false depending on whether the file refers to an
  absolute path specifier (like C</usr/local/foo.txt> or C<\Windows\Foo.txt>).
  
  =item $file->is_relative
  
  Returns true or false depending on whether the file refers to a
  relative path specifier (like C<lib/foo.txt> or C<.\Foo.txt>).
  
  =item $file->cleanup
  
  Performs a logical cleanup of the file path.  For instance:
  
    my $file = file('/foo//baz/./foo.txt')->cleanup;
    # $file now represents '/foo/baz/foo.txt';
  
  =item $dir->resolve
  
  Performs a physical cleanup of the file path.  For instance:
  
    my $file = file('/foo/baz/../foo.txt')->resolve;
    # $file now represents '/foo/foo.txt', assuming no symlinks
  
  This actually consults the filesystem to verify the validity of the
  path.
  
  =item $dir = $file->dir
  
  Returns a C<Path::Class::Dir> object representing the directory
  containing this file.
  
  =item $dir = $file->parent
  
  A synonym for the C<dir()> method.
  
  =item $abs = $file->absolute
  
  Returns a C<Path::Class::File> object representing C<$file> as an
  absolute path.  An optional argument, given as either a string or a
  L<Path::Class::Dir> object, specifies the directory to use as the base
  of relativity - otherwise the current working directory will be used.
  
  =item $rel = $file->relative
  
  Returns a C<Path::Class::File> object representing C<$file> as a
  relative path.  An optional argument, given as either a string or a
  C<Path::Class::Dir> object, specifies the directory to use as the base
  of relativity - otherwise the current working directory will be used.
  
  =item $foreign = $file->as_foreign($type)
  
  Returns a C<Path::Class::File> object representing C<$file> as it would
  be specified on a system of type C<$type>.  Known types include
  C<Unix>, C<Win32>, C<Mac>, C<VMS>, and C<OS2>, i.e. anything for which
  there is a subclass of C<File::Spec>.
  
  Any generated objects (subdirectories, files, parents, etc.) will also
  retain this type.
  
  =item $foreign = Path::Class::File->new_foreign($type, @args)
  
  Returns a C<Path::Class::File> object representing a file as it would
  be specified on a system of type C<$type>.  Known types include
  C<Unix>, C<Win32>, C<Mac>, C<VMS>, and C<OS2>, i.e. anything for which
  there is a subclass of C<File::Spec>.
  
  The arguments in C<@args> are the same as they would be specified in
  C<new()>.
  
  =item $fh = $file->open($mode, $permissions)
  
  Passes the given arguments, including C<$file>, to C<< IO::File->new >>
  (which in turn calls C<< IO::File->open >> and returns the result
  as an L<IO::File> object.  If the opening
  fails, C<undef> is returned and C<$!> is set.
  
  =item $fh = $file->openr()
  
  A shortcut for
  
   $fh = $file->open('r') or croak "Can't read $file: $!";
  
  =item $fh = $file->openw()
  
  A shortcut for
  
   $fh = $file->open('w') or croak "Can't write to $file: $!";
  
  =item $fh = $file->opena()
  
  A shortcut for
  
   $fh = $file->open('a') or croak "Can't append to $file: $!";
  
  =item $file->touch
  
  Sets the modification and access time of the given file to right now,
  if the file exists.  If it doesn't exist, C<touch()> will I<make> it
  exist, and - YES! - set its modification and access time to now.
  
  =item $file->slurp()
  
  In a scalar context, returns the contents of C<$file> in a string.  In
  a list context, returns the lines of C<$file> (according to how C<$/>
  is set) as a list.  If the file can't be read, this method will throw
  an exception.
  
  If you want C<chomp()> run on each line of the file, pass a true value
  for the C<chomp> or C<chomped> parameters:
  
    my @lines = $file->slurp(chomp => 1);
  
  You may also use the C<iomode> parameter to pass in an IO mode to use
  when opening the file, usually IO layers (though anything accepted by
  the MODE argument of C<open()> is accepted here).  Just make sure it's
  a I<reading> mode.
  
    my @lines = $file->slurp(iomode => ':crlf');
    my $lines = $file->slurp(iomode => '<:encoding(UTF-8)');
  
  The default C<iomode> is C<r>.
  
  Lines can also be automatically splitted, mimicking the perl command-line
  option C<-a> by using the C<split> parameter. If this parameter is used,
  each line will be returned as an array ref.
  
      my @lines = $file->slurp( chomp => 1, split => qr/\s*,\s*/ );
  
  The C<split> parameter can only be used in a list context.
  
  =item $file->spew( $content );
  
  The opposite of L</slurp>, this takes a list of strings and prints them
  to the file in write mode.  If the file can't be written to, this method
  will throw an exception.
  
  The content to be written can be either an array ref or a plain scalar.
  If the content is an array ref then each entry in the array will be
  written to the file.
  
  You may use the C<iomode> parameter to pass in an IO mode to use when
  opening the file, just like L</slurp> supports.
  
    $file->spew(iomode => '>:raw', $content);
  
  The default C<iomode> is C<w>.
  
  =item $file->traverse(sub { ... }, @args)
  
  Calls the given callback on $file. This doesn't do much on its own,
  but see the associated documentation in L<Path::Class::Dir>.
  
  =item $file->remove()
  
  This method will remove the file in a way that works well on all
  platforms, and returns a boolean value indicating whether or not the
  file was successfully removed.  
  
  C<remove()> is better than simply calling Perl's C<unlink()> function,
  because on some platforms (notably VMS) you actually may need to call
  C<unlink()> several times before all versions of the file are gone -
  the C<remove()> method handles this process for you.
  
  =item $st = $file->stat()
  
  Invokes C<< File::stat::stat() >> on this file and returns a
  L<File::stat> object representing the result.
  
  =item $st = $file->lstat()
  
  Same as C<stat()>, but if C<$file> is a symbolic link, C<lstat()>
  stats the link instead of the file the link points to.
  
  =item $class = $file->dir_class()
  
  Returns the class which should be used to create directory objects.
  
  Generally overridden whenever this class is subclassed.
  
  =back
  
  =head1 AUTHOR
  
  Ken Williams, kwilliams@cpan.org
  
  =head1 SEE ALSO
  
  L<Path::Class>, L<Path::Class::Dir>, L<File::Spec>
  
  =cut
PATH_CLASS_FILE

$fatpacked{"lib/core/only.pm"} = <<'LIB_CORE_ONLY';
  package lib::core::only;
  
  use strict;
  use warnings FATAL => 'all';
  use Config;
  
  sub import {
    @INC = @Config{qw(privlibexp archlibexp)};
    return
  }
  
  =head1 NAME
  
  lib::core::only - Remove all non-core paths from @INC to avoid site/vendor dirs
  
  =head1 SYNOPSIS
  
    use lib::core::only; # now @INC contains only the two core directories
  
  To get only the core directories plus the ones for the local::lib in scope:
  
    $ perl -mlocal::lib -Mlib::core::only -Mlocal::lib=~/perl5 myscript.pl
  
  To attempt to do a self-contained build (but note this will not reliably
  propagate into subprocesses, see the CAVEATS below):
  
    $ PERL5OPT='-mlocal::lib -Mlib::core::only -Mlocal::lib=~/perl5' cpan
  
  Please note that it is necessary to use C<local::lib> twice for this to work.
  First so that C<lib::core::only> doesn't prevent C<local::lib> from loading
  (it's not currently in core) and then again after C<lib::core::only> so that
  the local paths are not removed.
  
  =head1 DESCRIPTION
  
  lib::core::only is simply a shortcut to say "please reduce my @INC to only
  the core lib and archlib (architecture-specific lib) directories of this perl".
  
  You might want to do this to ensure a local::lib contains only the code you
  need, or to test an L<App::FatPacker|App::FatPacker> tree, or to avoid known
  bad vendor packages.
  
  You might want to use this to try and install a self-contained tree of perl
  modules. Be warned that that probably won't work (see L</CAVEATS>).
  
  This module was extracted from L<local::lib|local::lib>'s --self-contained
  feature, and contains the only part that ever worked. I apologise to anybody
  who thought anything else did.
  
  =head1 CAVEATS
  
  This does B<not> propagate properly across perl invocations like local::lib's
  stuff does. It can't. It's only a module import, so it B<only affects the
  specific perl VM instance in which you load and import() it>.
  
  If you want to cascade it across invocations, you can set the PERL5OPT
  environment variable to '-Mlib::core::only' and it'll sort of work. But be
  aware that taint mode ignores this, so some modules' build and test code
  probably will as well.
  
  You also need to be aware that perl's command line options are not processed
  in order - -I options take effect before -M options, so
  
    perl -Mlib::core::only -Ilib
  
  is unlike to do what you want - it's exactly equivalent to:
  
    perl -Mlib::core::only
  
  If you want to combine a core-only @INC with additional paths, you need to
  add the additional paths using -M options and the L<lib|lib> module:
  
    perl -Mlib::core::only -Mlib=lib
  
    # or if you're trying to test compiled code:
  
    perl -Mlib::core::only -Mblib
  
  For more information on the impossibility of sanely propagating this across
  module builds without help from the build program, see
  L<http://www.shadowcat.co.uk/blog/matt-s-trout/tainted-love> - and for ways
  to achieve the old --self-contained feature's results, look at
  L<App::FatPacker|App::FatPacker>'s tree function, and at
  L<App::cpanminus|cpanm>'s --local-lib-contained feature.
  
  =head1 AUTHOR
  
  Matt S. Trout <mst@shadowcat.co.uk>
  
  =head1 LICENSE
  
  This library is free software under the same terms as perl itself.
  
  =head1 COPYRIGHT
  
  (c) 2010 the lib::core::only L</AUTHOR> as specified above.
  
  =cut
  
  1;
LIB_CORE_ONLY

$fatpacked{"local/lib.pm"} = <<'LOCAL_LIB';
  package local::lib;
  use 5.006;
  use strict;
  use warnings;
  use Config;
  
  our $VERSION = '2.000012';
  $VERSION = eval $VERSION;
  
  BEGIN {
    *_WIN32 = ($^O eq 'MSWin32' || $^O eq 'NetWare' || $^O eq 'symbian')
      ? sub(){1} : sub(){0};
    # punt on these systems
    *_USE_FSPEC = ($^O eq 'MacOS' || $^O eq 'VMS' || $INC{'File/Spec.pm'})
      ? sub(){1} : sub(){0};
  }
  our $_DIR_JOIN = _WIN32 ? '\\' : '/';
  our $_DIR_SPLIT = (_WIN32 || $^O eq 'cygwin') ? qr{[\\/]}
                                                : qr{/};
  our $_ROOT = _WIN32 ? do {
    my $UNC = qr{[\\/]{2}[^\\/]+[\\/][^\\/]+};
    qr{^(?:$UNC|[A-Za-z]:|)$_DIR_SPLIT};
  } : qr{^/};
  our $_PERL;
  
  sub _cwd {
    my $drive = shift;
    if (!$_PERL) {
      ($_PERL) = $^X =~ /(.+)/; # $^X is internal how could it be tainted?!
      if (_is_abs($_PERL)) {
      }
      elsif (-x $Config{perlpath}) {
        $_PERL = $Config{perlpath};
      }
      else {
        ($_PERL) =
          map { /(.*)/ }
          grep { -x $_ }
          map { join($_DIR_JOIN, $_, $_PERL) }
          split /\Q$Config{path_sep}\E/, $ENV{PATH};
      }
    }
    local @ENV{qw(PATH IFS CDPATH ENV BASH_ENV)};
    my $cmd = $drive ? "eval { Cwd::getdcwd(q($drive)) }"
                     : 'getcwd';
    my $cwd = `"$_PERL" -MCwd -le "print $cmd"`;
    chomp $cwd;
    if (!length $cwd && $drive) {
      $cwd = $drive;
    }
    $cwd =~ s/$_DIR_SPLIT?$/$_DIR_JOIN/;
    $cwd;
  }
  
  sub _catdir {
    if (_USE_FSPEC) {
      require File::Spec;
      File::Spec->catdir(@_);
    }
    else {
      my $dir = join($_DIR_JOIN, @_);
      $dir =~ s{($_DIR_SPLIT)(?:\.?$_DIR_SPLIT)+}{$1}g;
      $dir;
    }
  }
  
  sub _is_abs {
    if (_USE_FSPEC) {
      require File::Spec;
      File::Spec->file_name_is_absolute($_[0]);
    }
    else {
      $_[0] =~ $_ROOT;
    }
  }
  
  sub _rel2abs {
    my ($dir, $base) = @_;
    return $dir
      if _is_abs($dir);
  
    $base = _WIN32 && $dir =~ s/^([A-Za-z]:)// ? _cwd("$1")
          : $base                              ? $base
                                               : _cwd;
    return _catdir($base, $dir);
  }
  
  sub import {
    my ($class, @args) = @_;
    push @args, @ARGV
      if $0 eq '-';
  
    my @steps;
    my %opts;
    my $shelltype;
  
    while (@args) {
      my $arg = shift @args;
      # check for lethal dash first to stop processing before causing problems
      # the fancy dash is U+2212 or \xE2\x88\x92
      if ($arg =~ /\xE2\x88\x92/ or $arg =~ /−/) {
        die <<'DEATH';
  WHOA THERE! It looks like you've got some fancy dashes in your commandline!
  These are *not* the traditional -- dashes that software recognizes. You
  probably got these by copy-pasting from the perldoc for this module as
  rendered by a UTF8-capable formatter. This most typically happens on an OS X
  terminal, but can happen elsewhere too. Please try again after replacing the
  dashes with normal minus signs.
  DEATH
      }
      elsif ($arg eq '--self-contained') {
        die <<'DEATH';
  FATAL: The local::lib --self-contained flag has never worked reliably and the
  original author, Mark Stosberg, was unable or unwilling to maintain it. As
  such, this flag has been removed from the local::lib codebase in order to
  prevent misunderstandings and potentially broken builds. The local::lib authors
  recommend that you look at the lib::core::only module shipped with this
  distribution in order to create a more robust environment that is equivalent to
  what --self-contained provided (although quite possibly not what you originally
  thought it provided due to the poor quality of the documentation, for which we
  apologise).
  DEATH
      }
      elsif( $arg =~ /^--deactivate(?:=(.*))?$/ ) {
        my $path = defined $1 ? $1 : shift @args;
        push @steps, ['deactivate', $path];
      }
      elsif ( $arg eq '--deactivate-all' ) {
        push @steps, ['deactivate_all'];
      }
      elsif ( $arg =~ /^--shelltype(?:=(.*))?$/ ) {
        $shelltype = defined $1 ? $1 : shift @args;
      }
      elsif ( $arg eq '--no-create' ) {
        $opts{no_create} = 1;
      }
      elsif ( $arg =~ /^--/ ) {
        die "Unknown import argument: $arg";
      }
      else {
        push @steps, ['activate', $arg];
      }
    }
    if (!@steps) {
      push @steps, ['activate', undef];
    }
  
    my $self = $class->new(%opts);
  
    for (@steps) {
      my ($method, @args) = @$_;
      $self = $self->$method(@args);
    }
  
    if ($0 eq '-') {
      print $self->environment_vars_string($shelltype);
      exit 0;
    }
    else {
      $self->setup_local_lib;
    }
  }
  
  sub new {
    my $class = shift;
    bless {@_}, $class;
  }
  
  sub clone {
    my $self = shift;
    bless {%$self, @_}, ref $self;
  }
  
  sub inc { $_[0]->{inc}     ||= \@INC }
  sub libs { $_[0]->{libs}   ||= [ \'PERL5LIB' ] }
  sub bins { $_[0]->{bins}   ||= [ \'PATH' ] }
  sub roots { $_[0]->{roots} ||= [ \'PERL_LOCAL_LIB_ROOT' ] }
  sub extra { $_[0]->{extra} ||= {} }
  sub no_create { $_[0]->{no_create} }
  
  my $_archname = $Config{archname};
  my $_version  = $Config{version};
  my @_inc_version_list = reverse split / /, $Config{inc_version_list};
  my $_path_sep = $Config{path_sep};
  
  sub _as_list {
    my $list = shift;
    grep length, map {
      !(ref $_ && ref $_ eq 'SCALAR') ? $_ : (
        defined $ENV{$$_} ? split(/\Q$_path_sep/, $ENV{$$_})
                          : ()
      )
    } ref $list ? @$list : $list;
  }
  sub _remove_from {
    my ($list, @remove) = @_;
    return @$list
      if !@remove;
    my %remove = map { $_ => 1 } @remove;
    grep !$remove{$_}, _as_list($list);
  }
  
  my @_lib_subdirs = (
    [$_version, $_archname],
    [$_version],
    [$_archname],
    (@_inc_version_list ? \@_inc_version_list : ()),
    [],
  );
  
  sub install_base_bin_path {
    my ($class, $path) = @_;
    return _catdir($path, 'bin');
  }
  sub install_base_perl_path {
    my ($class, $path) = @_;
    return _catdir($path, 'lib', 'perl5');
  }
  sub install_base_arch_path {
    my ($class, $path) = @_;
    _catdir($class->install_base_perl_path($path), $_archname);
  }
  
  sub lib_paths_for {
    my ($class, $path) = @_;
    my $base = $class->install_base_perl_path($path);
    return map { _catdir($base, @$_) } @_lib_subdirs;
  }
  
  sub _mm_escape_path {
    my $path = shift;
    $path =~ s/\\/\\\\\\\\/g;
    if ($path =~ s/ /\\ /g) {
      $path = qq{"\\"$path\\""};
    }
    return $path;
  }
  
  sub _mb_escape_path {
    my $path = shift;
    $path =~ s/\\/\\\\/g;
    return qq{"$path"};
  }
  
  sub installer_options_for {
    my ($class, $path) = @_;
    return (
      PERL_MM_OPT =>
        defined $path ? "INSTALL_BASE="._mm_escape_path($path) : undef,
      PERL_MB_OPT =>
        defined $path ? "--install_base "._mb_escape_path($path) : undef,
    );
  }
  
  sub active_paths {
    my ($self) = @_;
    $self = ref $self ? $self : $self->new;
  
    return grep {
      # screen out entries that aren't actually reflected in @INC
      my $active_ll = $self->install_base_perl_path($_);
      grep { $_ eq $active_ll } @{$self->inc};
    } _as_list($self->roots);
  }
  
  
  sub deactivate {
    my ($self, $path) = @_;
    $self = $self->new unless ref $self;
    $path = $self->resolve_path($path);
    $path = $self->normalize_path($path);
  
    my @active_lls = $self->active_paths;
  
    if (!grep { $_ eq $path } @active_lls) {
      warn "Tried to deactivate inactive local::lib '$path'\n";
      return $self;
    }
  
    my %args = (
      bins  => [ _remove_from($self->bins,
        $self->install_base_bin_path($path)) ],
      libs  => [ _remove_from($self->libs,
        $self->install_base_perl_path($path)) ],
      inc   => [ _remove_from($self->inc,
        $self->lib_paths_for($path)) ],
      roots => [ _remove_from($self->roots, $path) ],
    );
  
    $args{extra} = { $self->installer_options_for($args{roots}[0]) };
  
    $self->clone(%args);
  }
  
  sub deactivate_all {
    my ($self) = @_;
    $self = $self->new unless ref $self;
  
    my @active_lls = $self->active_paths;
  
    my %args;
    if (@active_lls) {
      %args = (
        bins => [ _remove_from($self->bins,
          map $self->install_base_bin_path($_), @active_lls) ],
        libs => [ _remove_from($self->libs,
          map $self->install_base_perl_path($_), @active_lls) ],
        inc => [ _remove_from($self->inc,
          map $self->lib_paths_for($_), @active_lls) ],
        roots => [ _remove_from($self->roots, @active_lls) ],
      );
    }
  
    $args{extra} = { $self->installer_options_for(undef) };
  
    $self->clone(%args);
  }
  
  sub activate {
    my ($self, $path) = @_;
    $self = $self->new unless ref $self;
    $path = $self->resolve_path($path);
    $self->ensure_dir_structure_for($path)
      unless $self->no_create;
  
    $path = $self->normalize_path($path);
  
    my @active_lls = $self->active_paths;
  
    if (grep { $_ eq $path } @active_lls[1 .. $#active_lls]) {
      $self = $self->deactivate($path);
    }
  
    my %args;
    if (!@active_lls || $active_lls[0] ne $path) {
      %args = (
        bins  => [ $self->install_base_bin_path($path), @{$self->bins} ],
        libs  => [ $self->install_base_perl_path($path), @{$self->libs} ],
        inc   => [ $self->lib_paths_for($path), @{$self->inc} ],
        roots => [ $path, @{$self->roots} ],
      );
    }
  
    $args{extra} = { $self->installer_options_for($path) };
  
    $self->clone(%args);
  }
  
  sub normalize_path {
    my ($self, $path) = @_;
    $path = ( Win32::GetShortPathName($path) || $path )
      if $^O eq 'MSWin32';
    return $path;
  }
  
  sub build_environment_vars_for {
    my $self = $_[0]->new->activate($_[1]);
    $self->build_environment_vars;
  }
  sub build_activate_environment_vars_for {
    my $self = $_[0]->new->activate($_[1]);
    $self->build_environment_vars;
  }
  sub build_deactivate_environment_vars_for {
    my $self = $_[0]->new->deactivate($_[1]);
    $self->build_environment_vars;
  }
  sub build_deact_all_environment_vars_for {
    my $self = $_[0]->new->deactivate_all;
    $self->build_environment_vars;
  }
  sub build_environment_vars {
    my $self = shift;
    (
      PATH                => join($_path_sep, _as_list($self->bins)),
      PERL5LIB            => join($_path_sep, _as_list($self->libs)),
      PERL_LOCAL_LIB_ROOT => join($_path_sep, _as_list($self->roots)),
      %{$self->extra},
    );
  }
  
  sub setup_local_lib_for {
    my $self = $_[0]->new->activate($_[1]);
    $self->setup_local_lib;
  }
  
  sub setup_local_lib {
    my $self = shift;
  
    # if Carp is already loaded, ensure Carp::Heavy is also loaded, to avoid
    # $VERSION mismatch errors (Carp::Heavy loads Carp, so we do not need to
    # check in the other direction)
    require Carp::Heavy if $INC{'Carp.pm'};
  
    $self->setup_env_hash;
    @INC = @{$self->inc};
  }
  
  sub setup_env_hash_for {
    my $self = $_[0]->new->activate($_[1]);
    $self->setup_env_hash;
  }
  sub setup_env_hash {
    my $self = shift;
    my %env = $self->build_environment_vars;
    for my $key (keys %env) {
      if (defined $env{$key}) {
        $ENV{$key} = $env{$key};
      }
      else {
        delete $ENV{$key};
      }
    }
  }
  
  sub print_environment_vars_for {
    print $_[0]->environment_vars_string_for(@_[1..$#_]);
  }
  
  sub environment_vars_string_for {
    my $self = $_[0]->new->activate($_[1]);
    $self->environment_vars_string;
  }
  sub environment_vars_string {
    my ($self, $shelltype) = @_;
  
    $shelltype ||= $self->guess_shelltype;
  
    my $build_method = "build_${shelltype}_env_declaration";
  
    my $extra = $self->extra;
    my @envs = (
      PATH                => $self->bins,
      PERL5LIB            => $self->libs,
      PERL_LOCAL_LIB_ROOT => $self->roots,
      map { $_ => $extra->{$_} } sort keys %$extra,
    );
    my $out = '';
    while (@envs) {
      my ($name, $value) = (shift(@envs), shift(@envs));
      if (
          ref $value
          && @$value == 1
          && ref $value->[0]
          && ref $value->[0] eq 'SCALAR'
          && ${$value->[0]} eq $name) {
        next;
      }
      $out .= $self->$build_method($name, $value);
    }
    my $wrap_method = "wrap_${shelltype}_output";
    if ($self->can($wrap_method)) {
      return $self->$wrap_method($out);
    }
    return $out;
  }
  
  sub build_bourne_env_declaration {
    my ($class, $name, $args) = @_;
    my $value = $class->_interpolate($args, '$%s', '"', '\\%s');
  
    if (!defined $value) {
      return qq{unset $name;\n};
    }
  
    $value =~ s/(^|\G|$_path_sep)\$$name$_path_sep/$1\$$name\${$name+$_path_sep}/g;
    $value =~ s/$_path_sep\$$name$/\${$name+$_path_sep}\$$name/;
  
    qq{${name}="$value"; export ${name};\n}
  }
  
  sub build_csh_env_declaration {
    my ($class, $name, $args) = @_;
    my ($value, @vars) = $class->_interpolate($args, '$%s', '"', '"\\%s"');
    if (!defined $value) {
      return qq{unsetenv $name;\n};
    }
  
    my $out = '';
    for my $var (@vars) {
      $out .= qq{if ! \$?$name setenv $name '';\n};
    }
  
    my $value_without = $value;
    if ($value_without =~ s/(?:^|$_path_sep)\$$name(?:$_path_sep|$)//g) {
      $out .= qq{if "\$$name" != '' setenv $name "$value";\n};
      $out .= qq{if "\$$name" == '' };
    }
    $out .= qq{setenv $name "$value_without";\n};
    return $out;
  }
  
  sub build_cmd_env_declaration {
    my ($class, $name, $args) = @_;
    my $value = $class->_interpolate($args, '%%%s%%', qr([()!^"<>&|]), '^%s');
    if (!$value) {
      return qq{\@set $name=\n};
    }
  
    my $out = '';
    my $value_without = $value;
    if ($value_without =~ s/(?:^|$_path_sep)%$name%(?:$_path_sep|$)//g) {
      $out .= qq{\@if not "%$name%"=="" set $name=$value\n};
      $out .= qq{\@if "%$name%"=="" };
    }
    $out .= qq{\@set $name=$value_without\n};
    return $out;
  }
  
  sub build_powershell_env_declaration {
    my ($class, $name, $args) = @_;
    my $value = $class->_interpolate($args, '$env:%s', '"', '`%s');
  
    if (!$value) {
      return qq{Remove-Item -ErrorAction 0 Env:\\$name;\n};
    }
  
    my $maybe_path_sep = qq{\$(if("\$env:$name"-eq""){""}else{"$_path_sep"})};
    $value =~ s/(^|\G|$_path_sep)\$env:$name$_path_sep/$1\$env:$name"+$maybe_path_sep+"/g;
    $value =~ s/$_path_sep\$env:$name$/"+$maybe_path_sep+\$env:$name+"/;
  
    qq{\$env:$name = \$("$value");\n};
  }
  sub wrap_powershell_output {
    my ($class, $out) = @_;
    return $out || " \n";
  }
  
  sub build_fish_env_declaration {
    my ($class, $name, $args) = @_;
    my $value = $class->_interpolate($args, '$%s', qr/[" ]/, '\\%s');
    if (!defined $value) {
      return qq{set -e $name;\n};
    }
    $value =~ s/$_path_sep/ /g;
    qq{set -x $name $value;\n};
  }
  
  sub _interpolate {
    my ($class, $args, $var_pat, $escape, $escape_pat) = @_;
    return
      unless defined $args;
    my @args = ref $args ? @$args : $args;
    return
      unless @args;
    my @vars = map { $$_ } grep { ref $_ eq 'SCALAR' } @args;
    my $string = join $_path_sep, map {
      ref $_ eq 'SCALAR' ? sprintf($var_pat, $$_) : do {
        s/($escape)/sprintf($escape_pat, $1)/ge; $_;
      };
    } @args;
    return wantarray ? ($string, \@vars) : $string;
  }
  
  sub pipeline;
  
  sub pipeline {
    my @methods = @_;
    my $last = pop(@methods);
    if (@methods) {
      \sub {
        my ($obj, @args) = @_;
        $obj->${pipeline @methods}(
          $obj->$last(@args)
        );
      };
    } else {
      \sub {
        shift->$last(@_);
      };
    }
  }
  
  sub resolve_path {
    my ($class, $path) = @_;
  
    $path = $class->${pipeline qw(
      resolve_relative_path
      resolve_home_path
      resolve_empty_path
    )}($path);
  
    $path;
  }
  
  sub resolve_empty_path {
    my ($class, $path) = @_;
    if (defined $path) {
      $path;
    } else {
      '~/perl5';
    }
  }
  
  sub resolve_home_path {
    my ($class, $path) = @_;
    $path =~ /^~([^\/]*)/ or return $path;
    my $user = $1;
    my $homedir = do {
      if (! length($user) && defined $ENV{HOME}) {
        $ENV{HOME};
      }
      else {
        require File::Glob;
        File::Glob::bsd_glob("~$user", File::Glob::GLOB_TILDE());
      }
    };
    unless (defined $homedir) {
      require Carp; require Carp::Heavy;
      Carp::croak(
        "Couldn't resolve homedir for "
        .(defined $user ? $user : 'current user')
      );
    }
    $path =~ s/^~[^\/]*/$homedir/;
    $path;
  }
  
  sub resolve_relative_path {
    my ($class, $path) = @_;
    _rel2abs($path);
  }
  
  sub ensure_dir_structure_for {
    my ($class, $path) = @_;
    unless (-d $path) {
      warn "Attempting to create directory ${path}\n";
    }
    require File::Basename;
    my @dirs;
    while(!-d $path) {
      push @dirs, $path;
      $path = File::Basename::dirname($path);
    }
    mkdir $_ for reverse @dirs;
    return;
  }
  
  sub guess_shelltype {
    my $shellbin
      = defined $ENV{SHELL}
        ? ($ENV{SHELL} =~ /([\w.]+)$/)[-1]
      : ( $^O eq 'MSWin32' && exists $ENV{'!EXITCODE'} )
        ? 'bash'
      : ( $^O eq 'MSWin32' && $ENV{PROMPT} && $ENV{COMSPEC} )
        ? ($ENV{COMSPEC} =~ /([\w.]+)$/)[-1]
      : ( $^O eq 'MSWin32' && !$ENV{PROMPT} )
        ? 'powershell.exe'
      : 'sh';
  
    for ($shellbin) {
      return
          /csh$/                   ? 'csh'
        : /fish/                   ? 'fish'
        : /command(?:\.com)?$/i    ? 'cmd'
        : /cmd(?:\.exe)?$/i        ? 'cmd'
        : /4nt(?:\.exe)?$/i        ? 'cmd'
        : /powershell(?:\.exe)?$/i ? 'powershell'
                                   : 'bourne';
    }
  }
  
  1;
  __END__
  
  =encoding utf8
  
  =head1 NAME
  
  local::lib - create and use a local lib/ for perl modules with PERL5LIB
  
  =head1 SYNOPSIS
  
  In code -
  
    use local::lib; # sets up a local lib at ~/perl5
  
    use local::lib '~/foo'; # same, but ~/foo
  
    # Or...
    use FindBin;
    use local::lib "$FindBin::Bin/../support";  # app-local support library
  
  From the shell -
  
    # Install LWP and its missing dependencies to the '~/perl5' directory
    perl -MCPAN -Mlocal::lib -e 'CPAN::install(LWP)'
  
    # Just print out useful shell commands
    $ perl -Mlocal::lib
    PERL_MB_OPT='--install_base /home/username/perl5'; export PERL_MB_OPT;
    PERL_MM_OPT='INSTALL_BASE=/home/username/perl5'; export PERL_MM_OPT;
    PERL5LIB="/home/username/perl5/lib/perl5"; export PERL5LIB;
    PATH="/home/username/perl5/bin:$PATH"; export PATH;
    PERL_LOCAL_LIB_ROOT="/home/usename/perl5:$PERL_LOCAL_LIB_ROOT"; export PERL_LOCAL_LIB_ROOT;
  
  From a .bashrc file -
  
    [ $SHLVL -eq 1 ] && eval "$(perl -I$HOME/perl5/lib/perl5 -Mlocal::lib)"
  
  =head2 The bootstrapping technique
  
  A typical way to install local::lib is using what is known as the
  "bootstrapping" technique.  You would do this if your system administrator
  hasn't already installed local::lib.  In this case, you'll need to install
  local::lib in your home directory.
  
  Even if you do have administrative privileges, you will still want to set up your
  environment variables, as discussed in step 4. Without this, you would still
  install the modules into the system CPAN installation and also your Perl scripts
  will not use the lib/ path you bootstrapped with local::lib.
  
  By default local::lib installs itself and the CPAN modules into ~/perl5.
  
  Windows users must also see L</Differences when using this module under Win32>.
  
  =over 4
  
  =item 1.
  
  Download and unpack the local::lib tarball from CPAN (search for "Download"
  on the CPAN page about local::lib).  Do this as an ordinary user, not as root
  or administrator.  Unpack the file in your home directory or in any other
  convenient location.
  
  =item 2.
  
  Run this:
  
    perl Makefile.PL --bootstrap
  
  If the system asks you whether it should automatically configure as much
  as possible, you would typically answer yes.
  
  In order to install local::lib into a directory other than the default, you need
  to specify the name of the directory when you call bootstrap, as follows:
  
    perl Makefile.PL --bootstrap=~/foo
  
  =item 3.
  
  Run this: (local::lib assumes you have make installed on your system)
  
    make test && make install
  
  =item 4.
  
  Now we need to setup the appropriate environment variables, so that Perl
  starts using our newly generated lib/ directory. If you are using bash or
  any other Bourne shells, you can add this to your shell startup script this
  way:
  
    echo '[ $SHLVL -eq 1 ] && eval "$(perl -I$HOME/perl5/lib/perl5 -Mlocal::lib)"' >>~/.bashrc
  
  If you are using C shell, you can do this as follows:
  
    /bin/csh
    echo $SHELL
    /bin/csh
    echo 'eval `perl -I$HOME/perl5/lib/perl5 -Mlocal::lib`' >> ~/.cshrc
  
  If you passed to bootstrap a directory other than default, you also need to
  give that as import parameter to the call of the local::lib module like this
  way:
  
    echo '[ $SHLVL -eq 1 ] && eval "$(perl -I$HOME/foo/lib/perl5 -Mlocal::lib=$HOME/foo)"' >>~/.bashrc
  
  After writing your shell configuration file, be sure to re-read it to get the
  changed settings into your current shell's environment. Bourne shells use
  C<. ~/.bashrc> for this, whereas C shells use C<source ~/.cshrc>.
  
  =back
  
  If you're on a slower machine, or are operating under draconian disk space
  limitations, you can disable the automatic generation of manpages from POD when
  installing modules by using the C<--no-manpages> argument when bootstrapping:
  
    perl Makefile.PL --bootstrap --no-manpages
  
  To avoid doing several bootstrap for several Perl module environments on the
  same account, for example if you use it for several different deployed
  applications independently, you can use one bootstrapped local::lib
  installation to install modules in different directories directly this way:
  
    cd ~/mydir1
    perl -Mlocal::lib=./
    eval $(perl -Mlocal::lib=./)  ### To set the environment for this shell alone
    printenv                      ### You will see that ~/mydir1 is in the PERL5LIB
    perl -MCPAN -e install ...    ### whatever modules you want
    cd ../mydir2
    ... REPEAT ...
  
  When used in a C<.bashrc> file, it is recommended that you protect against
  re-activating a directory in a sub-shell.  This can be done by checking the
  C<$SHLVL> variable as shown in synopsis.  Without this, sub-shells created by
  the user or other programs will override changes made to the parent shell's
  environment.
  
  If you are working with several C<local::lib> environments, you may want to
  remove some of them from the current environment without disturbing the others.
  You can deactivate one environment like this (using bourne sh):
  
    eval $(perl -Mlocal::lib=--deactivate,~/path)
  
  which will generate and run the commands needed to remove C<~/path> from your
  various search paths. Whichever environment was B<activated most recently> will
  remain the target for module installations. That is, if you activate
  C<~/path_A> and then you activate C<~/path_B>, new modules you install will go
  in C<~/path_B>. If you deactivate C<~/path_B> then modules will be installed
  into C<~/pathA> -- but if you deactivate C<~/path_A> then they will still be
  installed in C<~/pathB> because pathB was activated later.
  
  You can also ask C<local::lib> to clean itself completely out of the current
  shell's environment with the C<--deactivate-all> option.
  For multiple environments for multiple apps you may need to include a modified
  version of the C<< use FindBin >> instructions in the "In code" sample above.
  If you did something like the above, you have a set of Perl modules at C<<
  ~/mydir1/lib >>. If you have a script at C<< ~/mydir1/scripts/myscript.pl >>,
  you need to tell it where to find the modules you installed for it at C<<
  ~/mydir1/lib >>.
  
  In C<< ~/mydir1/scripts/myscript.pl >>:
  
    use strict;
    use warnings;
    use local::lib "$FindBin::Bin/..";  ### points to ~/mydir1 and local::lib finds lib
    use lib "$FindBin::Bin/../lib";     ### points to ~/mydir1/lib
  
  Put this before any BEGIN { ... } blocks that require the modules you installed.
  
  =head2 Differences when using this module under Win32
  
  To set up the proper environment variables for your current session of
  C<CMD.exe>, you can use this:
  
    C:\>perl -Mlocal::lib
    set PERL_MB_OPT=--install_base C:\DOCUME~1\ADMINI~1\perl5
    set PERL_MM_OPT=INSTALL_BASE=C:\DOCUME~1\ADMINI~1\perl5
    set PERL5LIB=C:\DOCUME~1\ADMINI~1\perl5\lib\perl5
    set PATH=C:\DOCUME~1\ADMINI~1\perl5\bin;%PATH%
  
    ### To set the environment for this shell alone
    C:\>perl -Mlocal::lib > %TEMP%\tmp.bat && %TEMP%\tmp.bat && del %TEMP%\tmp.bat
    ### instead of $(perl -Mlocal::lib=./)
  
  If you want the environment entries to persist, you'll need to add them to the
  Control Panel's System applet yourself or use L<App::local::lib::Win32Helper>.
  
  The "~" is translated to the user's profile directory (the directory named for
  the user under "Documents and Settings" (Windows XP or earlier) or "Users"
  (Windows Vista or later)) unless $ENV{HOME} exists. After that, the home
  directory is translated to a short name (which means the directory must exist)
  and the subdirectories are created.
  
  =head3 PowerShell
  
  local::lib also supports PowerShell, and can be used with the
  C<Invoke-Expression> cmdlet.
  
    Invoke-Expression "$(perl -Mlocal::lib)"
  
  =head1 RATIONALE
  
  The version of a Perl package on your machine is not always the version you
  need.  Obviously, the best thing to do would be to update to the version you
  need.  However, you might be in a situation where you're prevented from doing
  this.  Perhaps you don't have system administrator privileges; or perhaps you
  are using a package management system such as Debian, and nobody has yet gotten
  around to packaging up the version you need.
  
  local::lib solves this problem by allowing you to create your own directory of
  Perl packages downloaded from CPAN (in a multi-user system, this would typically
  be within your own home directory).  The existing system Perl installation is
  not affected; you simply invoke Perl with special options so that Perl uses the
  packages in your own local package directory rather than the system packages.
  local::lib arranges things so that your locally installed version of the Perl
  packages takes precedence over the system installation.
  
  If you are using a package management system (such as Debian), you don't need to
  worry about Debian and CPAN stepping on each other's toes.  Your local version
  of the packages will be written to an entirely separate directory from those
  installed by Debian.
  
  =head1 DESCRIPTION
  
  This module provides a quick, convenient way of bootstrapping a user-local Perl
  module library located within the user's home directory. It also constructs and
  prints out for the user the list of environment variables using the syntax
  appropriate for the user's current shell (as specified by the C<SHELL>
  environment variable), suitable for directly adding to one's shell
  configuration file.
  
  More generally, local::lib allows for the bootstrapping and usage of a
  directory containing Perl modules outside of Perl's C<@INC>. This makes it
  easier to ship an application with an app-specific copy of a Perl module, or
  collection of modules. Useful in cases like when an upstream maintainer hasn't
  applied a patch to a module of theirs that you need for your application.
  
  On import, local::lib sets the following environment variables to appropriate
  values:
  
  =over 4
  
  =item PERL_MB_OPT
  
  =item PERL_MM_OPT
  
  =item PERL5LIB
  
  =item PATH
  
  =item PERL_LOCAL_LIB_ROOT
  
  =back
  
  When possible, these will be appended to instead of overwritten entirely.
  
  These values are then available for reference by any code after import.
  
  =head1 CREATING A SELF-CONTAINED SET OF MODULES
  
  See L<lib::core::only> for one way to do this - but note that
  there are a number of caveats, and the best approach is always to perform a
  build against a clean perl (i.e. site and vendor as close to empty as possible).
  
  =head1 IMPORT OPTIONS
  
  Options are values that can be passed to the C<local::lib> import besides the
  directory to use. They are specified as C<use local::lib '--option'[, path];>
  or C<perl -Mlocal::lib=--option[,path]>.
  
  =head2 --deactivate
  
  Remove the chosen path (or the default path) from the module search paths if it
  was added by C<local::lib>, instead of adding it.
  
  =head2 --deactivate-all
  
  Remove all directories that were added to search paths by C<local::lib> from the
  search paths.
  
  =head2 --shelltype
  
  Specify the shell type to use for output.  By default, the shell will be
  detected based on the environment.  Should be one of: C<bourne>, C<csh>,
  C<cmd>, or C<powershell>.
  
  =head2 --no-create
  
  Prevents C<local::lib> from creating directories when activating dirs.  This is
  likely to cause issues on Win32 systems.
  
  =head1 CLASS METHODS
  
  =head2 ensure_dir_structure_for
  
  =over 4
  
  =item Arguments: $path
  
  =item Return value: None
  
  =back
  
  Attempts to create the given path, and all required parent directories. Throws
  an exception on failure.
  
  =head2 print_environment_vars_for
  
  =over 4
  
  =item Arguments: $path
  
  =item Return value: None
  
  =back
  
  Prints to standard output the variables listed above, properly set to use the
  given path as the base directory.
  
  =head2 build_environment_vars_for
  
  =over 4
  
  =item Arguments: $path
  
  =item Return value: %environment_vars
  
  =back
  
  Returns a hash with the variables listed above, properly set to use the
  given path as the base directory.
  
  =head2 setup_env_hash_for
  
  =over 4
  
  =item Arguments: $path
  
  =item Return value: None
  
  =back
  
  Constructs the C<%ENV> keys for the given path, by calling
  L</build_environment_vars_for>.
  
  =head2 active_paths
  
  =over 4
  
  =item Arguments: None
  
  =item Return value: @paths
  
  =back
  
  Returns a list of active C<local::lib> paths, according to the
  C<PERL_LOCAL_LIB_ROOT> environment variable and verified against
  what is really in C<@INC>.
  
  =head2 install_base_perl_path
  
  =over 4
  
  =item Arguments: $path
  
  =item Return value: $install_base_perl_path
  
  =back
  
  Returns a path describing where to install the Perl modules for this local
  library installation. Appends the directories C<lib> and C<perl5> to the given
  path.
  
  =head2 lib_paths_for
  
  =over 4
  
  =item Arguments: $path
  
  =item Return value: @lib_paths
  
  =back
  
  Returns the list of paths perl will search for libraries, given a base path.
  This includes the base path itself, the architecture specific subdirectory, and
  perl version specific subdirectories.  These paths may not all exist.
  
  =head2 install_base_bin_path
  
  =over 4
  
  =item Arguments: $path
  
  =item Return value: $install_base_bin_path
  
  =back
  
  Returns a path describing where to install the executable programs for this
  local library installation. Appends the directory C<bin> to the given path.
  
  =head2 installer_options_for
  
  =over 4
  
  =item Arguments: $path
  
  =item Return value: %installer_env_vars
  
  =back
  
  Returns a hash of environment variables that should be set to cause
  installation into the given path.
  
  =head2 resolve_empty_path
  
  =over 4
  
  =item Arguments: $path
  
  =item Return value: $base_path
  
  =back
  
  Builds and returns the base path into which to set up the local module
  installation. Defaults to C<~/perl5>.
  
  =head2 resolve_home_path
  
  =over 4
  
  =item Arguments: $path
  
  =item Return value: $home_path
  
  =back
  
  Attempts to find the user's home directory. If installed, uses C<File::HomeDir>
  for this purpose. If no definite answer is available, throws an exception.
  
  =head2 resolve_relative_path
  
  =over 4
  
  =item Arguments: $path
  
  =item Return value: $absolute_path
  
  =back
  
  Translates the given path into an absolute path.
  
  =head2 resolve_path
  
  =over 4
  
  =item Arguments: $path
  
  =item Return value: $absolute_path
  
  =back
  
  Calls the following in a pipeline, passing the result from the previous to the
  next, in an attempt to find where to configure the environment for a local
  library installation: L</resolve_empty_path>, L</resolve_home_path>,
  L</resolve_relative_path>. Passes the given path argument to
  L</resolve_empty_path> which then returns a result that is passed to
  L</resolve_home_path>, which then has its result passed to
  L</resolve_relative_path>. The result of this final call is returned from
  L</resolve_path>.
  
  =head1 OBJECT INTERFACE
  
  =head2 new
  
  =over 4
  
  =item Arguments: %attributes
  
  =item Return value: $local_lib
  
  =back
  
  Constructs a new C<local::lib> object, representing the current state of
  C<@INC> and the relevant environment variables.
  
  =head1 ATTRIBUTES
  
  =head2 roots
  
  An arrayref representing active C<local::lib> directories.
  
  =head2 inc
  
  An arrayref representing C<@INC>.
  
  =head2 libs
  
  An arrayref representing the PERL5LIB environment variable.
  
  =head2 bins
  
  An arrayref representing the PATH environment variable.
  
  =head2 extra
  
  A hashref of extra environment variables (e.g. C<PERL_MM_OPT> and
  C<PERL_MB_OPT>)
  
  =head2 no_create
  
  If set, C<local::lib> will not try to create directories when activating them.
  
  =head1 OBJECT METHODS
  
  =head2 clone
  
  =over 4
  
  =item Arguments: %attributes
  
  =item Return value: $local_lib
  
  =back
  
  Constructs a new C<local::lib> object based on the existing one, overriding the
  specified attributes.
  
  =head2 activate
  
  =over 4
  
  =item Arguments: $path
  
  =item Return value: $new_local_lib
  
  =back
  
  Constructs a new instance with the specified path active.
  
  =head2 deactivate
  
  =over 4
  
  =item Arguments: $path
  
  =item Return value: $new_local_lib
  
  =back
  
  Constructs a new instance with the specified path deactivated.
  
  =head2 deactivate_all
  
  =over 4
  
  =item Arguments: None
  
  =item Return value: $new_local_lib
  
  =back
  
  Constructs a new instance with all C<local::lib> directories deactivated.
  
  =head2 environment_vars_string
  
  =over 4
  
  =item Arguments: [ $shelltype ]
  
  =item Return value: $shell_env_string
  
  =back
  
  Returns a string to set up the C<local::lib>, meant to be run by a shell.
  
  =head2 build_environment_vars
  
  =over 4
  
  =item Arguments: None
  
  =item Return value: %environment_vars
  
  =back
  
  Returns a hash with the variables listed above, properly set to use the
  given path as the base directory.
  
  =head2 setup_env_hash
  
  =over 4
  
  =item Arguments: None
  
  =item Return value: None
  
  =back
  
  Constructs the C<%ENV> keys for the given path, by calling
  L</build_environment_vars>.
  
  =head2 setup_local_lib
  
  Constructs the C<%ENV> hash using L</setup_env_hash>, and set up C<@INC>.
  
  =head1 A WARNING ABOUT UNINST=1
  
  Be careful about using local::lib in combination with "make install UNINST=1".
  The idea of this feature is that will uninstall an old version of a module
  before installing a new one. However it lacks a safety check that the old
  version and the new version will go in the same directory. Used in combination
  with local::lib, you can potentially delete a globally accessible version of a
  module while installing the new version in a local place. Only combine "make
  install UNINST=1" and local::lib if you understand these possible consequences.
  
  =head1 LIMITATIONS
  
  =over 4
  
  =item * Directory names with spaces in them are not well supported by the perl
  toolchain and the programs it uses.  Pure-perl distributions should support
  spaces, but problems are more likely with dists that require compilation. A
  workaround you can do is moving your local::lib to a directory with spaces
  B<after> you installed all modules inside your local::lib bootstrap. But be
  aware that you can't update or install CPAN modules after the move.
  
  =item * Rather basic shell detection. Right now anything with csh in its name is
  assumed to be a C shell or something compatible, and everything else is assumed
  to be Bourne, except on Win32 systems. If the C<SHELL> environment variable is
  not set, a Bourne-compatible shell is assumed.
  
  =item * Kills any existing PERL_MM_OPT or PERL_MB_OPT.
  
  =item * Should probably auto-fixup CPAN config if not already done.
  
  =item * On VMS and MacOS Classic (pre-OS X), local::lib loads L<File::Spec>.
  This means any L<File::Spec> version installed in the local::lib will be
  ignored by scripts using local::lib.  A workaround for this is using
  C<use lib "$local_lib/lib/perl5";> instead of using C<local::lib> directly.
  
  =item * Conflicts with L<ExtUtils::MakeMaker>'s C<PREFIX> option.
  C<local::lib> uses the C<INSTALL_BASE> option, as it has more predictable and
  sane behavior.  If something attempts to use the C<PREFIX> option when running
  a F<Makefile.PL>, L<ExtUtils::MakeMaker> will refuse to run, as the two
  options conflict.  This can be worked around by temporarily unsetting the
  C<PERL_MM_OPT> environment variable.
  
  =item * Conflicts with L<Module::Build>'s C<--prefix> option.  Similar to the
  previous limitation, but any C<--prefix> option specified will be ignored.
  This can be worked around by temporarily unsetting the C<PERL_MB_OPT>
  environment variable.
  
  =back
  
  Patches very much welcome for any of the above.
  
  =over 4
  
  =item * On Win32 systems, does not have a way to write the created environment
  variables to the registry, so that they can persist through a reboot.
  
  =back
  
  =head1 TROUBLESHOOTING
  
  If you've configured local::lib to install CPAN modules somewhere in to your
  home directory, and at some point later you try to install a module with C<cpan
  -i Foo::Bar>, but it fails with an error like: C<Warning: You do not have
  permissions to install into /usr/lib64/perl5/site_perl/5.8.8/x86_64-linux at
  /usr/lib64/perl5/5.8.8/Foo/Bar.pm> and buried within the install log is an
  error saying C<'INSTALL_BASE' is not a known MakeMaker parameter name>, then
  you've somehow lost your updated ExtUtils::MakeMaker module.
  
  To remedy this situation, rerun the bootstrapping procedure documented above.
  
  Then, run C<rm -r ~/.cpan/build/Foo-Bar*>
  
  Finally, re-run C<cpan -i Foo::Bar> and it should install without problems.
  
  =head1 ENVIRONMENT
  
  =over 4
  
  =item SHELL
  
  =item COMSPEC
  
  local::lib looks at the user's C<SHELL> environment variable when printing out
  commands to add to the shell configuration file.
  
  On Win32 systems, C<COMSPEC> is also examined.
  
  =back
  
  =head1 SEE ALSO
  
  =over 4
  
  =item * L<Perl Advent article, 2011|http://perladvent.org/2011/2011-12-01.html>
  
  =back
  
  =head1 SUPPORT
  
  IRC:
  
      Join #local-lib on irc.perl.org.
  
  =head1 AUTHOR
  
  Matt S Trout <mst@shadowcat.co.uk> http://www.shadowcat.co.uk/
  
  auto_install fixes kindly sponsored by http://www.takkle.com/
  
  =head1 CONTRIBUTORS
  
  Patches to correctly output commands for csh style shells, as well as some
  documentation additions, contributed by Christopher Nehren <apeiron@cpan.org>.
  
  Doc patches for a custom local::lib directory, more cleanups in the english
  documentation and a L<german documentation|POD2::DE::local::lib> contributed by
  Torsten Raudssus <torsten@raudssus.de>.
  
  Hans Dieter Pearcey <hdp@cpan.org> sent in some additional tests for ensuring
  things will install properly, submitted a fix for the bug causing problems with
  writing Makefiles during bootstrapping, contributed an example program, and
  submitted yet another fix to ensure that local::lib can install and bootstrap
  properly. Many, many thanks!
  
  pattern of Freenode IRC contributed the beginnings of the Troubleshooting
  section. Many thanks!
  
  Patch to add Win32 support contributed by Curtis Jewell <csjewell@cpan.org>.
  
  Warnings for missing PATH/PERL5LIB (as when not running interactively) silenced
  by a patch from Marco Emilio Poleggi.
  
  Mark Stosberg <mark@summersault.com> provided the code for the now deleted
  '--self-contained' option.
  
  Documentation patches to make win32 usage clearer by
  David Mertens <dcmertens.perl@gmail.com> (run4flat).
  
  Brazilian L<portuguese translation|POD2::PT_BR::local::lib> and minor doc
  patches contributed by Breno G. de Oliveira <garu@cpan.org>.
  
  Improvements to stacking multiple local::lib dirs and removing them from the
  environment later on contributed by Andrew Rodland <arodland@cpan.org>.
  
  Patch for Carp version mismatch contributed by Hakim Cassimally
  <osfameron@cpan.org>.
  
  Rewrite of internals and numerous bug fixes and added features contributed by
  Graham Knop <haarg@haarg.org>.
  
  =head1 COPYRIGHT
  
  Copyright (c) 2007 - 2013 the local::lib L</AUTHOR> and L</CONTRIBUTORS> as
  listed above.
  
  =head1 LICENSE
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
LOCAL_LIB

s/^  //mg for values %fatpacked;

unshift @INC, sub {
  if (my $fat = $fatpacked{$_[1]}) {
    if ($] < 5.008) {
      return sub {
        return 0 unless length $fat;
        $fat =~ s/^([^\n]*\n?)//;
        $_ = $1;
        return 1;
      };
    }
    open my $fh, '<', \$fat
      or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
    return $fh;
  }
  return
};

} # END OF FATPACK CODE

use strict;
use warnings;

use FindBin qw($Bin);
use lib "$Bin/../p5-shelly/lib", "$Bin/../p5-shelly/fatlib";
use App::shelly;

use Pod::Usage;

unless (caller) {
    my $app = App::shelly->new;
    $app->parse_options(@ARGV);
    if ( $app->{help} ) {
        pod2usage( verbose => 1, -exitval => 'noexit' );
    }
    $app->doit or exit(1);
}

__END__

=head1 NAME

App::shelly

=head1 SYNOPSIS

$ shly [options] [atom...]

=head1 OPTIONS

=over 4

=item B<-h, --help>

Show this help.

=item B<-I [directory]>

Specify asdf:*central-registry* directory (several -I's allowed).

=item B<-L, --load [library]>

Specify a library to be loaded before executing the expression (several -L's allowed).

=item B<-V, --version>

Print the version of Shelly and exit.

=item B<--verbose>

Print some informations.

=item B<--debug>

This flag is for Shelly developers.

=back

